// <auto-generated>
// This .cs file is generated by T4 template. Don't change it. Change the .tt file instead.
// </auto-generated>
#nullable enable

using System;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using FastEnumUtility.UnitTests.Models;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Shouldly;

namespace FastEnumUtility.UnitTests.Cases.Reflections;



[TestClass]
public sealed class ContinuousSByteTests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<ContinuousSByteEnum>().ShouldBe(typeof(sbyte));


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<ContinuousSByteEnum>();
        var actual = FastEnum.GetValues<ContinuousSByteEnum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<ContinuousSByteEnum>();
        var actual = FastEnum.GetNames<ContinuousSByteEnum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousSByteEnum>())
        {
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.ShouldNotBeNull();
            actual.ShouldBe(expect);
        }
        //--- undefined value
        {
            const ContinuousSByteEnum undefined = (ContinuousSByteEnum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.ShouldBeNull();
            actual.ShouldBe(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<ContinuousSByteEnum>()
            .Select(static name =>
            {
                var value = Enum.Parse<ContinuousSByteEnum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(ContinuousSByteEnum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<ContinuousSByteEnum>();

        actual.Length.ShouldBe(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.ShouldBe(e.value);
            a.Name.ShouldBe(e.name);
            a.NameUtf8.ShouldBe(e.nameUtf8);
            a.FieldInfo.ShouldBe(e.fieldInfo);

            var (name, value) = a;
            value.ShouldBe(e.value);
            name.ShouldBe(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousSByteEnum>())
        {
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.ShouldNotBeNull();
            actual.Value.ShouldBe(expect.value);
            actual.Name.ShouldBe(expect.name);
            actual.NameUtf8.ShouldBe(expect.nameUtf8);
            actual.FieldInfo.ShouldBe(expect.fieldInfo);

            var (name, value) = actual;
            value.ShouldBe(expect.value);
            name.ShouldBe(expect.name);
        }
        //--- undefined value
        {
            const ContinuousSByteEnum undefined = (ContinuousSByteEnum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.ShouldBeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<ContinuousSByteEnum>();
        min.ShouldNotBeNull();
        min.ShouldBe(ContinuousSByteEnum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<ContinuousSByteEnum>();
        max.ShouldNotBeNull();
        max.ShouldBe(ContinuousSByteEnum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<ContinuousSByteEnum>().ShouldBe(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<ContinuousSByteEnum>().ShouldBe(true);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<ContinuousSByteEnum>().ShouldBe(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<ContinuousSByteEnum>(ContinuousSByteEnum.A).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousSByteEnum>(ContinuousSByteEnum.B).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousSByteEnum>(ContinuousSByteEnum.C).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousSByteEnum>((ContinuousSByteEnum)0).ShouldBeFalse();
        FastEnum.IsDefined<ContinuousSByteEnum>((ContinuousSByteEnum)123).ShouldBeFalse();

        //--- Extension methods
        ContinuousSByteEnum.A.IsDefined().ShouldBeTrue();
        ContinuousSByteEnum.B.IsDefined().ShouldBeTrue();
        ContinuousSByteEnum.C.IsDefined().ShouldBeTrue();
        ((ContinuousSByteEnum)0).IsDefined().ShouldBeFalse();
        ((ContinuousSByteEnum)123).IsDefined().ShouldBeFalse();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<ContinuousSByteEnum>(nameof(ContinuousSByteEnum.A)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousSByteEnum>(nameof(ContinuousSByteEnum.B)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousSByteEnum>(nameof(ContinuousSByteEnum.C)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousSByteEnum>("0").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousSByteEnum>("123").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousSByteEnum>("value").ShouldBeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousSByteEnum.A, name: nameof(ContinuousSByteEnum.A)),
            (value: ContinuousSByteEnum.B, name: nameof(ContinuousSByteEnum.B)),
            (value: ContinuousSByteEnum.C, name: nameof(ContinuousSByteEnum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((sbyte)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousSByteEnum>(x.name, ignoreCase).ShouldBe(x.value);
            Should.Throw<ArgumentException>(() => FastEnum.Parse<ContinuousSByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase));
            FastEnum.Parse<ContinuousSByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousSByteEnum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousSByteEnum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousSByteEnum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousSByteEnum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousSByteEnum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousSByteEnum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousSByteEnum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousSByteEnum>("123", ignoreCase).ShouldBe((ContinuousSByteEnum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousSByteEnum.A, name: nameof(ContinuousSByteEnum.A)),
            (value: ContinuousSByteEnum.B, name: nameof(ContinuousSByteEnum.B)),
            (value: ContinuousSByteEnum.C, name: nameof(ContinuousSByteEnum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((sbyte)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousSByteEnum>(x.name, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousSByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousSByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousSByteEnum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousSByteEnum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousSByteEnum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousSByteEnum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousSByteEnum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousSByteEnum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousSByteEnum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousSByteEnum>("123", ignoreCase).ShouldBe((ContinuousSByteEnum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousSByteEnum.A, name: nameof(ContinuousSByteEnum.A)),
            (value: ContinuousSByteEnum.B, name: nameof(ContinuousSByteEnum.B)),
            (value: ContinuousSByteEnum.C, name: nameof(ContinuousSByteEnum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((sbyte)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousSByteEnum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousSByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeFalse();
            FastEnum.TryParse<ContinuousSByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeTrue();

            FastEnum.TryParse<ContinuousSByteEnum>(valueString, ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousSByteEnum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousSByteEnum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousSByteEnum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousSByteEnum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousSByteEnum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousSByteEnum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousSByteEnum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousSByteEnum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousSByteEnum.A, name: nameof(ContinuousSByteEnum.A)),
            (value: ContinuousSByteEnum.B, name: nameof(ContinuousSByteEnum.B)),
            (value: ContinuousSByteEnum.C, name: nameof(ContinuousSByteEnum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((sbyte)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousSByteEnum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousSByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousSByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousSByteEnum>(valueString, ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousSByteEnum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r5).ShouldBeTrue();
            r5.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousSByteEnum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r6).ShouldBeTrue();
            r6.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousSByteEnum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousSByteEnum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousSByteEnum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousSByteEnum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousSByteEnum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousSByteEnum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        const ContinuousSByteEnum value = ContinuousSByteEnum.A;
        const string name = nameof(ContinuousSByteEnum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(ContinuousSByteEnum).GetField(name);

        member.ShouldNotBeNull();
        member.Name.ShouldBe(name);
        member.NameUtf8.ShouldBe(nameUtf8);
        member.Value.ShouldBe(value);
        member.FieldInfo.ShouldBe(info);
    }


    [TestMethod]
    public void ToName()
    {
        ContinuousSByteEnum.A.ToName().ShouldBe(nameof(ContinuousSByteEnum.A));
        ContinuousSByteEnum.B.ToName().ShouldBe(nameof(ContinuousSByteEnum.B));
        ContinuousSByteEnum.C.ToName().ShouldBe(nameof(ContinuousSByteEnum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        const ContinuousSByteEnum @enum = ContinuousSByteEnum.A;
        const sbyte value = 1;

        @enum.ToSByte().ShouldBe(value);
        Should.Throw<ArgumentException>(static () => @enum.ToByte());
        Should.Throw<ArgumentException>(static () => @enum.ToInt16());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt16());
        Should.Throw<ArgumentException>(static () => @enum.ToInt32());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt32());
        Should.Throw<ArgumentException>(static () => @enum.ToInt64());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt64());
    }


    [TestMethod]
    public void FastToString()
    {
        const ContinuousSByteEnum undefined = (ContinuousSByteEnum)123;
        var values = Enum.GetValues<ContinuousSByteEnum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.ShouldBe(expect);
        }
    }
}



[TestClass]
public sealed class ContinuousByteTests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<ContinuousByteEnum>().ShouldBe(typeof(byte));


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<ContinuousByteEnum>();
        var actual = FastEnum.GetValues<ContinuousByteEnum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<ContinuousByteEnum>();
        var actual = FastEnum.GetNames<ContinuousByteEnum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousByteEnum>())
        {
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.ShouldNotBeNull();
            actual.ShouldBe(expect);
        }
        //--- undefined value
        {
            const ContinuousByteEnum undefined = (ContinuousByteEnum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.ShouldBeNull();
            actual.ShouldBe(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<ContinuousByteEnum>()
            .Select(static name =>
            {
                var value = Enum.Parse<ContinuousByteEnum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(ContinuousByteEnum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<ContinuousByteEnum>();

        actual.Length.ShouldBe(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.ShouldBe(e.value);
            a.Name.ShouldBe(e.name);
            a.NameUtf8.ShouldBe(e.nameUtf8);
            a.FieldInfo.ShouldBe(e.fieldInfo);

            var (name, value) = a;
            value.ShouldBe(e.value);
            name.ShouldBe(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousByteEnum>())
        {
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.ShouldNotBeNull();
            actual.Value.ShouldBe(expect.value);
            actual.Name.ShouldBe(expect.name);
            actual.NameUtf8.ShouldBe(expect.nameUtf8);
            actual.FieldInfo.ShouldBe(expect.fieldInfo);

            var (name, value) = actual;
            value.ShouldBe(expect.value);
            name.ShouldBe(expect.name);
        }
        //--- undefined value
        {
            const ContinuousByteEnum undefined = (ContinuousByteEnum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.ShouldBeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<ContinuousByteEnum>();
        min.ShouldNotBeNull();
        min.ShouldBe(ContinuousByteEnum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<ContinuousByteEnum>();
        max.ShouldNotBeNull();
        max.ShouldBe(ContinuousByteEnum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<ContinuousByteEnum>().ShouldBe(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<ContinuousByteEnum>().ShouldBe(true);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<ContinuousByteEnum>().ShouldBe(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<ContinuousByteEnum>(ContinuousByteEnum.A).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousByteEnum>(ContinuousByteEnum.B).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousByteEnum>(ContinuousByteEnum.C).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousByteEnum>((ContinuousByteEnum)0).ShouldBeFalse();
        FastEnum.IsDefined<ContinuousByteEnum>((ContinuousByteEnum)123).ShouldBeFalse();

        //--- Extension methods
        ContinuousByteEnum.A.IsDefined().ShouldBeTrue();
        ContinuousByteEnum.B.IsDefined().ShouldBeTrue();
        ContinuousByteEnum.C.IsDefined().ShouldBeTrue();
        ((ContinuousByteEnum)0).IsDefined().ShouldBeFalse();
        ((ContinuousByteEnum)123).IsDefined().ShouldBeFalse();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<ContinuousByteEnum>(nameof(ContinuousByteEnum.A)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousByteEnum>(nameof(ContinuousByteEnum.B)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousByteEnum>(nameof(ContinuousByteEnum.C)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousByteEnum>("0").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousByteEnum>("123").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousByteEnum>("value").ShouldBeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousByteEnum.A, name: nameof(ContinuousByteEnum.A)),
            (value: ContinuousByteEnum.B, name: nameof(ContinuousByteEnum.B)),
            (value: ContinuousByteEnum.C, name: nameof(ContinuousByteEnum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((byte)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousByteEnum>(x.name, ignoreCase).ShouldBe(x.value);
            Should.Throw<ArgumentException>(() => FastEnum.Parse<ContinuousByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase));
            FastEnum.Parse<ContinuousByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousByteEnum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousByteEnum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousByteEnum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousByteEnum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousByteEnum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousByteEnum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousByteEnum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousByteEnum>("123", ignoreCase).ShouldBe((ContinuousByteEnum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousByteEnum.A, name: nameof(ContinuousByteEnum.A)),
            (value: ContinuousByteEnum.B, name: nameof(ContinuousByteEnum.B)),
            (value: ContinuousByteEnum.C, name: nameof(ContinuousByteEnum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((byte)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousByteEnum>(x.name, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousByteEnum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousByteEnum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousByteEnum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousByteEnum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousByteEnum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousByteEnum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousByteEnum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousByteEnum>("123", ignoreCase).ShouldBe((ContinuousByteEnum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousByteEnum.A, name: nameof(ContinuousByteEnum.A)),
            (value: ContinuousByteEnum.B, name: nameof(ContinuousByteEnum.B)),
            (value: ContinuousByteEnum.C, name: nameof(ContinuousByteEnum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((byte)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousByteEnum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeFalse();
            FastEnum.TryParse<ContinuousByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeTrue();

            FastEnum.TryParse<ContinuousByteEnum>(valueString, ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousByteEnum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousByteEnum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousByteEnum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousByteEnum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousByteEnum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousByteEnum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousByteEnum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousByteEnum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousByteEnum.A, name: nameof(ContinuousByteEnum.A)),
            (value: ContinuousByteEnum.B, name: nameof(ContinuousByteEnum.B)),
            (value: ContinuousByteEnum.C, name: nameof(ContinuousByteEnum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((byte)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousByteEnum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousByteEnum>(valueString, ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousByteEnum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r5).ShouldBeTrue();
            r5.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousByteEnum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r6).ShouldBeTrue();
            r6.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousByteEnum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousByteEnum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousByteEnum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousByteEnum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousByteEnum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousByteEnum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        const ContinuousByteEnum value = ContinuousByteEnum.A;
        const string name = nameof(ContinuousByteEnum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(ContinuousByteEnum).GetField(name);

        member.ShouldNotBeNull();
        member.Name.ShouldBe(name);
        member.NameUtf8.ShouldBe(nameUtf8);
        member.Value.ShouldBe(value);
        member.FieldInfo.ShouldBe(info);
    }


    [TestMethod]
    public void ToName()
    {
        ContinuousByteEnum.A.ToName().ShouldBe(nameof(ContinuousByteEnum.A));
        ContinuousByteEnum.B.ToName().ShouldBe(nameof(ContinuousByteEnum.B));
        ContinuousByteEnum.C.ToName().ShouldBe(nameof(ContinuousByteEnum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        const ContinuousByteEnum @enum = ContinuousByteEnum.A;
        const byte value = 1;

        Should.Throw<ArgumentException>(static () => @enum.ToSByte());
        @enum.ToByte().ShouldBe(value);
        Should.Throw<ArgumentException>(static () => @enum.ToInt16());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt16());
        Should.Throw<ArgumentException>(static () => @enum.ToInt32());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt32());
        Should.Throw<ArgumentException>(static () => @enum.ToInt64());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt64());
    }


    [TestMethod]
    public void FastToString()
    {
        const ContinuousByteEnum undefined = (ContinuousByteEnum)123;
        var values = Enum.GetValues<ContinuousByteEnum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.ShouldBe(expect);
        }
    }
}



[TestClass]
public sealed class ContinuousInt16Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<ContinuousInt16Enum>().ShouldBe(typeof(short));


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<ContinuousInt16Enum>();
        var actual = FastEnum.GetValues<ContinuousInt16Enum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<ContinuousInt16Enum>();
        var actual = FastEnum.GetNames<ContinuousInt16Enum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousInt16Enum>())
        {
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.ShouldNotBeNull();
            actual.ShouldBe(expect);
        }
        //--- undefined value
        {
            const ContinuousInt16Enum undefined = (ContinuousInt16Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.ShouldBeNull();
            actual.ShouldBe(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<ContinuousInt16Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<ContinuousInt16Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(ContinuousInt16Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<ContinuousInt16Enum>();

        actual.Length.ShouldBe(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.ShouldBe(e.value);
            a.Name.ShouldBe(e.name);
            a.NameUtf8.ShouldBe(e.nameUtf8);
            a.FieldInfo.ShouldBe(e.fieldInfo);

            var (name, value) = a;
            value.ShouldBe(e.value);
            name.ShouldBe(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousInt16Enum>())
        {
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.ShouldNotBeNull();
            actual.Value.ShouldBe(expect.value);
            actual.Name.ShouldBe(expect.name);
            actual.NameUtf8.ShouldBe(expect.nameUtf8);
            actual.FieldInfo.ShouldBe(expect.fieldInfo);

            var (name, value) = actual;
            value.ShouldBe(expect.value);
            name.ShouldBe(expect.name);
        }
        //--- undefined value
        {
            const ContinuousInt16Enum undefined = (ContinuousInt16Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.ShouldBeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<ContinuousInt16Enum>();
        min.ShouldNotBeNull();
        min.ShouldBe(ContinuousInt16Enum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<ContinuousInt16Enum>();
        max.ShouldNotBeNull();
        max.ShouldBe(ContinuousInt16Enum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<ContinuousInt16Enum>().ShouldBe(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<ContinuousInt16Enum>().ShouldBe(true);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<ContinuousInt16Enum>().ShouldBe(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<ContinuousInt16Enum>(ContinuousInt16Enum.A).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt16Enum>(ContinuousInt16Enum.B).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt16Enum>(ContinuousInt16Enum.C).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt16Enum>((ContinuousInt16Enum)0).ShouldBeFalse();
        FastEnum.IsDefined<ContinuousInt16Enum>((ContinuousInt16Enum)123).ShouldBeFalse();

        //--- Extension methods
        ContinuousInt16Enum.A.IsDefined().ShouldBeTrue();
        ContinuousInt16Enum.B.IsDefined().ShouldBeTrue();
        ContinuousInt16Enum.C.IsDefined().ShouldBeTrue();
        ((ContinuousInt16Enum)0).IsDefined().ShouldBeFalse();
        ((ContinuousInt16Enum)123).IsDefined().ShouldBeFalse();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<ContinuousInt16Enum>(nameof(ContinuousInt16Enum.A)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt16Enum>(nameof(ContinuousInt16Enum.B)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt16Enum>(nameof(ContinuousInt16Enum.C)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt16Enum>("0").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousInt16Enum>("123").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousInt16Enum>("value").ShouldBeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousInt16Enum.A, name: nameof(ContinuousInt16Enum.A)),
            (value: ContinuousInt16Enum.B, name: nameof(ContinuousInt16Enum.B)),
            (value: ContinuousInt16Enum.C, name: nameof(ContinuousInt16Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((short)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousInt16Enum>(x.name, ignoreCase).ShouldBe(x.value);
            Should.Throw<ArgumentException>(() => FastEnum.Parse<ContinuousInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase));
            FastEnum.Parse<ContinuousInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt16Enum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt16Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt16Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt16Enum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt16Enum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt16Enum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt16Enum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousInt16Enum>("123", ignoreCase).ShouldBe((ContinuousInt16Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousInt16Enum.A, name: nameof(ContinuousInt16Enum.A)),
            (value: ContinuousInt16Enum.B, name: nameof(ContinuousInt16Enum.B)),
            (value: ContinuousInt16Enum.C, name: nameof(ContinuousInt16Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((short)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousInt16Enum>(x.name, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt16Enum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt16Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt16Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt16Enum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt16Enum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt16Enum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt16Enum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousInt16Enum>("123", ignoreCase).ShouldBe((ContinuousInt16Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousInt16Enum.A, name: nameof(ContinuousInt16Enum.A)),
            (value: ContinuousInt16Enum.B, name: nameof(ContinuousInt16Enum.B)),
            (value: ContinuousInt16Enum.C, name: nameof(ContinuousInt16Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((short)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousInt16Enum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeFalse();
            FastEnum.TryParse<ContinuousInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeTrue();

            FastEnum.TryParse<ContinuousInt16Enum>(valueString, ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt16Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt16Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousInt16Enum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt16Enum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt16Enum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt16Enum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt16Enum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousInt16Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousInt16Enum.A, name: nameof(ContinuousInt16Enum.A)),
            (value: ContinuousInt16Enum.B, name: nameof(ContinuousInt16Enum.B)),
            (value: ContinuousInt16Enum.C, name: nameof(ContinuousInt16Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((short)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousInt16Enum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt16Enum>(valueString, ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt16Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r5).ShouldBeTrue();
            r5.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt16Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r6).ShouldBeTrue();
            r6.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousInt16Enum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt16Enum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt16Enum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt16Enum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt16Enum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousInt16Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        const ContinuousInt16Enum value = ContinuousInt16Enum.A;
        const string name = nameof(ContinuousInt16Enum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(ContinuousInt16Enum).GetField(name);

        member.ShouldNotBeNull();
        member.Name.ShouldBe(name);
        member.NameUtf8.ShouldBe(nameUtf8);
        member.Value.ShouldBe(value);
        member.FieldInfo.ShouldBe(info);
    }


    [TestMethod]
    public void ToName()
    {
        ContinuousInt16Enum.A.ToName().ShouldBe(nameof(ContinuousInt16Enum.A));
        ContinuousInt16Enum.B.ToName().ShouldBe(nameof(ContinuousInt16Enum.B));
        ContinuousInt16Enum.C.ToName().ShouldBe(nameof(ContinuousInt16Enum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        const ContinuousInt16Enum @enum = ContinuousInt16Enum.A;
        const short value = 1;

        Should.Throw<ArgumentException>(static () => @enum.ToSByte());
        Should.Throw<ArgumentException>(static () => @enum.ToByte());
        @enum.ToInt16().ShouldBe(value);
        Should.Throw<ArgumentException>(static () => @enum.ToUInt16());
        Should.Throw<ArgumentException>(static () => @enum.ToInt32());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt32());
        Should.Throw<ArgumentException>(static () => @enum.ToInt64());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt64());
    }


    [TestMethod]
    public void FastToString()
    {
        const ContinuousInt16Enum undefined = (ContinuousInt16Enum)123;
        var values = Enum.GetValues<ContinuousInt16Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.ShouldBe(expect);
        }
    }
}



[TestClass]
public sealed class ContinuousUInt16Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<ContinuousUInt16Enum>().ShouldBe(typeof(ushort));


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<ContinuousUInt16Enum>();
        var actual = FastEnum.GetValues<ContinuousUInt16Enum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<ContinuousUInt16Enum>();
        var actual = FastEnum.GetNames<ContinuousUInt16Enum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousUInt16Enum>())
        {
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.ShouldNotBeNull();
            actual.ShouldBe(expect);
        }
        //--- undefined value
        {
            const ContinuousUInt16Enum undefined = (ContinuousUInt16Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.ShouldBeNull();
            actual.ShouldBe(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<ContinuousUInt16Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<ContinuousUInt16Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(ContinuousUInt16Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<ContinuousUInt16Enum>();

        actual.Length.ShouldBe(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.ShouldBe(e.value);
            a.Name.ShouldBe(e.name);
            a.NameUtf8.ShouldBe(e.nameUtf8);
            a.FieldInfo.ShouldBe(e.fieldInfo);

            var (name, value) = a;
            value.ShouldBe(e.value);
            name.ShouldBe(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousUInt16Enum>())
        {
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.ShouldNotBeNull();
            actual.Value.ShouldBe(expect.value);
            actual.Name.ShouldBe(expect.name);
            actual.NameUtf8.ShouldBe(expect.nameUtf8);
            actual.FieldInfo.ShouldBe(expect.fieldInfo);

            var (name, value) = actual;
            value.ShouldBe(expect.value);
            name.ShouldBe(expect.name);
        }
        //--- undefined value
        {
            const ContinuousUInt16Enum undefined = (ContinuousUInt16Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.ShouldBeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<ContinuousUInt16Enum>();
        min.ShouldNotBeNull();
        min.ShouldBe(ContinuousUInt16Enum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<ContinuousUInt16Enum>();
        max.ShouldNotBeNull();
        max.ShouldBe(ContinuousUInt16Enum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<ContinuousUInt16Enum>().ShouldBe(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<ContinuousUInt16Enum>().ShouldBe(true);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<ContinuousUInt16Enum>().ShouldBe(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<ContinuousUInt16Enum>(ContinuousUInt16Enum.A).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt16Enum>(ContinuousUInt16Enum.B).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt16Enum>(ContinuousUInt16Enum.C).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt16Enum>((ContinuousUInt16Enum)0).ShouldBeFalse();
        FastEnum.IsDefined<ContinuousUInt16Enum>((ContinuousUInt16Enum)123).ShouldBeFalse();

        //--- Extension methods
        ContinuousUInt16Enum.A.IsDefined().ShouldBeTrue();
        ContinuousUInt16Enum.B.IsDefined().ShouldBeTrue();
        ContinuousUInt16Enum.C.IsDefined().ShouldBeTrue();
        ((ContinuousUInt16Enum)0).IsDefined().ShouldBeFalse();
        ((ContinuousUInt16Enum)123).IsDefined().ShouldBeFalse();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<ContinuousUInt16Enum>(nameof(ContinuousUInt16Enum.A)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt16Enum>(nameof(ContinuousUInt16Enum.B)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt16Enum>(nameof(ContinuousUInt16Enum.C)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt16Enum>("0").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousUInt16Enum>("123").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousUInt16Enum>("value").ShouldBeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousUInt16Enum.A, name: nameof(ContinuousUInt16Enum.A)),
            (value: ContinuousUInt16Enum.B, name: nameof(ContinuousUInt16Enum.B)),
            (value: ContinuousUInt16Enum.C, name: nameof(ContinuousUInt16Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((ushort)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousUInt16Enum>(x.name, ignoreCase).ShouldBe(x.value);
            Should.Throw<ArgumentException>(() => FastEnum.Parse<ContinuousUInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase));
            FastEnum.Parse<ContinuousUInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt16Enum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt16Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt16Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt16Enum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt16Enum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt16Enum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt16Enum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousUInt16Enum>("123", ignoreCase).ShouldBe((ContinuousUInt16Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousUInt16Enum.A, name: nameof(ContinuousUInt16Enum.A)),
            (value: ContinuousUInt16Enum.B, name: nameof(ContinuousUInt16Enum.B)),
            (value: ContinuousUInt16Enum.C, name: nameof(ContinuousUInt16Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((ushort)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousUInt16Enum>(x.name, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt16Enum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt16Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt16Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt16Enum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt16Enum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt16Enum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt16Enum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousUInt16Enum>("123", ignoreCase).ShouldBe((ContinuousUInt16Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousUInt16Enum.A, name: nameof(ContinuousUInt16Enum.A)),
            (value: ContinuousUInt16Enum.B, name: nameof(ContinuousUInt16Enum.B)),
            (value: ContinuousUInt16Enum.C, name: nameof(ContinuousUInt16Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((ushort)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousUInt16Enum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeFalse();
            FastEnum.TryParse<ContinuousUInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeTrue();

            FastEnum.TryParse<ContinuousUInt16Enum>(valueString, ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt16Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt16Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousUInt16Enum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt16Enum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt16Enum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt16Enum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt16Enum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousUInt16Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousUInt16Enum.A, name: nameof(ContinuousUInt16Enum.A)),
            (value: ContinuousUInt16Enum.B, name: nameof(ContinuousUInt16Enum.B)),
            (value: ContinuousUInt16Enum.C, name: nameof(ContinuousUInt16Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((ushort)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousUInt16Enum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt16Enum>(valueString, ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt16Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r5).ShouldBeTrue();
            r5.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt16Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r6).ShouldBeTrue();
            r6.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousUInt16Enum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt16Enum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt16Enum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt16Enum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt16Enum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousUInt16Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        const ContinuousUInt16Enum value = ContinuousUInt16Enum.A;
        const string name = nameof(ContinuousUInt16Enum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(ContinuousUInt16Enum).GetField(name);

        member.ShouldNotBeNull();
        member.Name.ShouldBe(name);
        member.NameUtf8.ShouldBe(nameUtf8);
        member.Value.ShouldBe(value);
        member.FieldInfo.ShouldBe(info);
    }


    [TestMethod]
    public void ToName()
    {
        ContinuousUInt16Enum.A.ToName().ShouldBe(nameof(ContinuousUInt16Enum.A));
        ContinuousUInt16Enum.B.ToName().ShouldBe(nameof(ContinuousUInt16Enum.B));
        ContinuousUInt16Enum.C.ToName().ShouldBe(nameof(ContinuousUInt16Enum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        const ContinuousUInt16Enum @enum = ContinuousUInt16Enum.A;
        const ushort value = 1;

        Should.Throw<ArgumentException>(static () => @enum.ToSByte());
        Should.Throw<ArgumentException>(static () => @enum.ToByte());
        Should.Throw<ArgumentException>(static () => @enum.ToInt16());
        @enum.ToUInt16().ShouldBe(value);
        Should.Throw<ArgumentException>(static () => @enum.ToInt32());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt32());
        Should.Throw<ArgumentException>(static () => @enum.ToInt64());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt64());
    }


    [TestMethod]
    public void FastToString()
    {
        const ContinuousUInt16Enum undefined = (ContinuousUInt16Enum)123;
        var values = Enum.GetValues<ContinuousUInt16Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.ShouldBe(expect);
        }
    }
}



[TestClass]
public sealed class ContinuousInt32Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<ContinuousInt32Enum>().ShouldBe(typeof(int));


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<ContinuousInt32Enum>();
        var actual = FastEnum.GetValues<ContinuousInt32Enum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<ContinuousInt32Enum>();
        var actual = FastEnum.GetNames<ContinuousInt32Enum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousInt32Enum>())
        {
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.ShouldNotBeNull();
            actual.ShouldBe(expect);
        }
        //--- undefined value
        {
            const ContinuousInt32Enum undefined = (ContinuousInt32Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.ShouldBeNull();
            actual.ShouldBe(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<ContinuousInt32Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<ContinuousInt32Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(ContinuousInt32Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<ContinuousInt32Enum>();

        actual.Length.ShouldBe(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.ShouldBe(e.value);
            a.Name.ShouldBe(e.name);
            a.NameUtf8.ShouldBe(e.nameUtf8);
            a.FieldInfo.ShouldBe(e.fieldInfo);

            var (name, value) = a;
            value.ShouldBe(e.value);
            name.ShouldBe(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousInt32Enum>())
        {
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.ShouldNotBeNull();
            actual.Value.ShouldBe(expect.value);
            actual.Name.ShouldBe(expect.name);
            actual.NameUtf8.ShouldBe(expect.nameUtf8);
            actual.FieldInfo.ShouldBe(expect.fieldInfo);

            var (name, value) = actual;
            value.ShouldBe(expect.value);
            name.ShouldBe(expect.name);
        }
        //--- undefined value
        {
            const ContinuousInt32Enum undefined = (ContinuousInt32Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.ShouldBeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<ContinuousInt32Enum>();
        min.ShouldNotBeNull();
        min.ShouldBe(ContinuousInt32Enum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<ContinuousInt32Enum>();
        max.ShouldNotBeNull();
        max.ShouldBe(ContinuousInt32Enum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<ContinuousInt32Enum>().ShouldBe(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<ContinuousInt32Enum>().ShouldBe(true);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<ContinuousInt32Enum>().ShouldBe(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<ContinuousInt32Enum>(ContinuousInt32Enum.A).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt32Enum>(ContinuousInt32Enum.B).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt32Enum>(ContinuousInt32Enum.C).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt32Enum>((ContinuousInt32Enum)0).ShouldBeFalse();
        FastEnum.IsDefined<ContinuousInt32Enum>((ContinuousInt32Enum)123).ShouldBeFalse();

        //--- Extension methods
        ContinuousInt32Enum.A.IsDefined().ShouldBeTrue();
        ContinuousInt32Enum.B.IsDefined().ShouldBeTrue();
        ContinuousInt32Enum.C.IsDefined().ShouldBeTrue();
        ((ContinuousInt32Enum)0).IsDefined().ShouldBeFalse();
        ((ContinuousInt32Enum)123).IsDefined().ShouldBeFalse();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<ContinuousInt32Enum>(nameof(ContinuousInt32Enum.A)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt32Enum>(nameof(ContinuousInt32Enum.B)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt32Enum>(nameof(ContinuousInt32Enum.C)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt32Enum>("0").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousInt32Enum>("123").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousInt32Enum>("value").ShouldBeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousInt32Enum.A, name: nameof(ContinuousInt32Enum.A)),
            (value: ContinuousInt32Enum.B, name: nameof(ContinuousInt32Enum.B)),
            (value: ContinuousInt32Enum.C, name: nameof(ContinuousInt32Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((int)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousInt32Enum>(x.name, ignoreCase).ShouldBe(x.value);
            Should.Throw<ArgumentException>(() => FastEnum.Parse<ContinuousInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase));
            FastEnum.Parse<ContinuousInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt32Enum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt32Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt32Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt32Enum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt32Enum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt32Enum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt32Enum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousInt32Enum>("123", ignoreCase).ShouldBe((ContinuousInt32Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousInt32Enum.A, name: nameof(ContinuousInt32Enum.A)),
            (value: ContinuousInt32Enum.B, name: nameof(ContinuousInt32Enum.B)),
            (value: ContinuousInt32Enum.C, name: nameof(ContinuousInt32Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((int)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousInt32Enum>(x.name, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt32Enum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt32Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt32Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt32Enum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt32Enum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt32Enum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt32Enum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousInt32Enum>("123", ignoreCase).ShouldBe((ContinuousInt32Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousInt32Enum.A, name: nameof(ContinuousInt32Enum.A)),
            (value: ContinuousInt32Enum.B, name: nameof(ContinuousInt32Enum.B)),
            (value: ContinuousInt32Enum.C, name: nameof(ContinuousInt32Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((int)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousInt32Enum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeFalse();
            FastEnum.TryParse<ContinuousInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeTrue();

            FastEnum.TryParse<ContinuousInt32Enum>(valueString, ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt32Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt32Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousInt32Enum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt32Enum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt32Enum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt32Enum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt32Enum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousInt32Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousInt32Enum.A, name: nameof(ContinuousInt32Enum.A)),
            (value: ContinuousInt32Enum.B, name: nameof(ContinuousInt32Enum.B)),
            (value: ContinuousInt32Enum.C, name: nameof(ContinuousInt32Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((int)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousInt32Enum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt32Enum>(valueString, ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt32Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r5).ShouldBeTrue();
            r5.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt32Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r6).ShouldBeTrue();
            r6.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousInt32Enum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt32Enum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt32Enum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt32Enum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt32Enum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousInt32Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        const ContinuousInt32Enum value = ContinuousInt32Enum.A;
        const string name = nameof(ContinuousInt32Enum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(ContinuousInt32Enum).GetField(name);

        member.ShouldNotBeNull();
        member.Name.ShouldBe(name);
        member.NameUtf8.ShouldBe(nameUtf8);
        member.Value.ShouldBe(value);
        member.FieldInfo.ShouldBe(info);
    }


    [TestMethod]
    public void ToName()
    {
        ContinuousInt32Enum.A.ToName().ShouldBe(nameof(ContinuousInt32Enum.A));
        ContinuousInt32Enum.B.ToName().ShouldBe(nameof(ContinuousInt32Enum.B));
        ContinuousInt32Enum.C.ToName().ShouldBe(nameof(ContinuousInt32Enum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        const ContinuousInt32Enum @enum = ContinuousInt32Enum.A;
        const int value = 1;

        Should.Throw<ArgumentException>(static () => @enum.ToSByte());
        Should.Throw<ArgumentException>(static () => @enum.ToByte());
        Should.Throw<ArgumentException>(static () => @enum.ToInt16());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt16());
        @enum.ToInt32().ShouldBe(value);
        Should.Throw<ArgumentException>(static () => @enum.ToUInt32());
        Should.Throw<ArgumentException>(static () => @enum.ToInt64());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt64());
    }


    [TestMethod]
    public void FastToString()
    {
        const ContinuousInt32Enum undefined = (ContinuousInt32Enum)123;
        var values = Enum.GetValues<ContinuousInt32Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.ShouldBe(expect);
        }
    }
}



[TestClass]
public sealed class ContinuousUInt32Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<ContinuousUInt32Enum>().ShouldBe(typeof(uint));


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<ContinuousUInt32Enum>();
        var actual = FastEnum.GetValues<ContinuousUInt32Enum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<ContinuousUInt32Enum>();
        var actual = FastEnum.GetNames<ContinuousUInt32Enum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousUInt32Enum>())
        {
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.ShouldNotBeNull();
            actual.ShouldBe(expect);
        }
        //--- undefined value
        {
            const ContinuousUInt32Enum undefined = (ContinuousUInt32Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.ShouldBeNull();
            actual.ShouldBe(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<ContinuousUInt32Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<ContinuousUInt32Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(ContinuousUInt32Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<ContinuousUInt32Enum>();

        actual.Length.ShouldBe(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.ShouldBe(e.value);
            a.Name.ShouldBe(e.name);
            a.NameUtf8.ShouldBe(e.nameUtf8);
            a.FieldInfo.ShouldBe(e.fieldInfo);

            var (name, value) = a;
            value.ShouldBe(e.value);
            name.ShouldBe(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousUInt32Enum>())
        {
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.ShouldNotBeNull();
            actual.Value.ShouldBe(expect.value);
            actual.Name.ShouldBe(expect.name);
            actual.NameUtf8.ShouldBe(expect.nameUtf8);
            actual.FieldInfo.ShouldBe(expect.fieldInfo);

            var (name, value) = actual;
            value.ShouldBe(expect.value);
            name.ShouldBe(expect.name);
        }
        //--- undefined value
        {
            const ContinuousUInt32Enum undefined = (ContinuousUInt32Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.ShouldBeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<ContinuousUInt32Enum>();
        min.ShouldNotBeNull();
        min.ShouldBe(ContinuousUInt32Enum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<ContinuousUInt32Enum>();
        max.ShouldNotBeNull();
        max.ShouldBe(ContinuousUInt32Enum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<ContinuousUInt32Enum>().ShouldBe(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<ContinuousUInt32Enum>().ShouldBe(true);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<ContinuousUInt32Enum>().ShouldBe(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<ContinuousUInt32Enum>(ContinuousUInt32Enum.A).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt32Enum>(ContinuousUInt32Enum.B).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt32Enum>(ContinuousUInt32Enum.C).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt32Enum>((ContinuousUInt32Enum)0).ShouldBeFalse();
        FastEnum.IsDefined<ContinuousUInt32Enum>((ContinuousUInt32Enum)123).ShouldBeFalse();

        //--- Extension methods
        ContinuousUInt32Enum.A.IsDefined().ShouldBeTrue();
        ContinuousUInt32Enum.B.IsDefined().ShouldBeTrue();
        ContinuousUInt32Enum.C.IsDefined().ShouldBeTrue();
        ((ContinuousUInt32Enum)0).IsDefined().ShouldBeFalse();
        ((ContinuousUInt32Enum)123).IsDefined().ShouldBeFalse();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<ContinuousUInt32Enum>(nameof(ContinuousUInt32Enum.A)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt32Enum>(nameof(ContinuousUInt32Enum.B)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt32Enum>(nameof(ContinuousUInt32Enum.C)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt32Enum>("0").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousUInt32Enum>("123").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousUInt32Enum>("value").ShouldBeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousUInt32Enum.A, name: nameof(ContinuousUInt32Enum.A)),
            (value: ContinuousUInt32Enum.B, name: nameof(ContinuousUInt32Enum.B)),
            (value: ContinuousUInt32Enum.C, name: nameof(ContinuousUInt32Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((uint)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousUInt32Enum>(x.name, ignoreCase).ShouldBe(x.value);
            Should.Throw<ArgumentException>(() => FastEnum.Parse<ContinuousUInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase));
            FastEnum.Parse<ContinuousUInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt32Enum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt32Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt32Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt32Enum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt32Enum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt32Enum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt32Enum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousUInt32Enum>("123", ignoreCase).ShouldBe((ContinuousUInt32Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousUInt32Enum.A, name: nameof(ContinuousUInt32Enum.A)),
            (value: ContinuousUInt32Enum.B, name: nameof(ContinuousUInt32Enum.B)),
            (value: ContinuousUInt32Enum.C, name: nameof(ContinuousUInt32Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((uint)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousUInt32Enum>(x.name, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt32Enum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt32Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt32Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt32Enum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt32Enum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt32Enum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt32Enum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousUInt32Enum>("123", ignoreCase).ShouldBe((ContinuousUInt32Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousUInt32Enum.A, name: nameof(ContinuousUInt32Enum.A)),
            (value: ContinuousUInt32Enum.B, name: nameof(ContinuousUInt32Enum.B)),
            (value: ContinuousUInt32Enum.C, name: nameof(ContinuousUInt32Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((uint)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousUInt32Enum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeFalse();
            FastEnum.TryParse<ContinuousUInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeTrue();

            FastEnum.TryParse<ContinuousUInt32Enum>(valueString, ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt32Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt32Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousUInt32Enum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt32Enum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt32Enum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt32Enum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt32Enum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousUInt32Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousUInt32Enum.A, name: nameof(ContinuousUInt32Enum.A)),
            (value: ContinuousUInt32Enum.B, name: nameof(ContinuousUInt32Enum.B)),
            (value: ContinuousUInt32Enum.C, name: nameof(ContinuousUInt32Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((uint)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousUInt32Enum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt32Enum>(valueString, ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt32Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r5).ShouldBeTrue();
            r5.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt32Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r6).ShouldBeTrue();
            r6.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousUInt32Enum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt32Enum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt32Enum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt32Enum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt32Enum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousUInt32Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        const ContinuousUInt32Enum value = ContinuousUInt32Enum.A;
        const string name = nameof(ContinuousUInt32Enum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(ContinuousUInt32Enum).GetField(name);

        member.ShouldNotBeNull();
        member.Name.ShouldBe(name);
        member.NameUtf8.ShouldBe(nameUtf8);
        member.Value.ShouldBe(value);
        member.FieldInfo.ShouldBe(info);
    }


    [TestMethod]
    public void ToName()
    {
        ContinuousUInt32Enum.A.ToName().ShouldBe(nameof(ContinuousUInt32Enum.A));
        ContinuousUInt32Enum.B.ToName().ShouldBe(nameof(ContinuousUInt32Enum.B));
        ContinuousUInt32Enum.C.ToName().ShouldBe(nameof(ContinuousUInt32Enum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        const ContinuousUInt32Enum @enum = ContinuousUInt32Enum.A;
        const uint value = 1;

        Should.Throw<ArgumentException>(static () => @enum.ToSByte());
        Should.Throw<ArgumentException>(static () => @enum.ToByte());
        Should.Throw<ArgumentException>(static () => @enum.ToInt16());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt16());
        Should.Throw<ArgumentException>(static () => @enum.ToInt32());
        @enum.ToUInt32().ShouldBe(value);
        Should.Throw<ArgumentException>(static () => @enum.ToInt64());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt64());
    }


    [TestMethod]
    public void FastToString()
    {
        const ContinuousUInt32Enum undefined = (ContinuousUInt32Enum)123;
        var values = Enum.GetValues<ContinuousUInt32Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.ShouldBe(expect);
        }
    }
}



[TestClass]
public sealed class ContinuousInt64Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<ContinuousInt64Enum>().ShouldBe(typeof(long));


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<ContinuousInt64Enum>();
        var actual = FastEnum.GetValues<ContinuousInt64Enum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<ContinuousInt64Enum>();
        var actual = FastEnum.GetNames<ContinuousInt64Enum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousInt64Enum>())
        {
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.ShouldNotBeNull();
            actual.ShouldBe(expect);
        }
        //--- undefined value
        {
            const ContinuousInt64Enum undefined = (ContinuousInt64Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.ShouldBeNull();
            actual.ShouldBe(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<ContinuousInt64Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<ContinuousInt64Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(ContinuousInt64Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<ContinuousInt64Enum>();

        actual.Length.ShouldBe(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.ShouldBe(e.value);
            a.Name.ShouldBe(e.name);
            a.NameUtf8.ShouldBe(e.nameUtf8);
            a.FieldInfo.ShouldBe(e.fieldInfo);

            var (name, value) = a;
            value.ShouldBe(e.value);
            name.ShouldBe(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousInt64Enum>())
        {
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.ShouldNotBeNull();
            actual.Value.ShouldBe(expect.value);
            actual.Name.ShouldBe(expect.name);
            actual.NameUtf8.ShouldBe(expect.nameUtf8);
            actual.FieldInfo.ShouldBe(expect.fieldInfo);

            var (name, value) = actual;
            value.ShouldBe(expect.value);
            name.ShouldBe(expect.name);
        }
        //--- undefined value
        {
            const ContinuousInt64Enum undefined = (ContinuousInt64Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.ShouldBeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<ContinuousInt64Enum>();
        min.ShouldNotBeNull();
        min.ShouldBe(ContinuousInt64Enum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<ContinuousInt64Enum>();
        max.ShouldNotBeNull();
        max.ShouldBe(ContinuousInt64Enum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<ContinuousInt64Enum>().ShouldBe(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<ContinuousInt64Enum>().ShouldBe(true);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<ContinuousInt64Enum>().ShouldBe(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<ContinuousInt64Enum>(ContinuousInt64Enum.A).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt64Enum>(ContinuousInt64Enum.B).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt64Enum>(ContinuousInt64Enum.C).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt64Enum>((ContinuousInt64Enum)0).ShouldBeFalse();
        FastEnum.IsDefined<ContinuousInt64Enum>((ContinuousInt64Enum)123).ShouldBeFalse();

        //--- Extension methods
        ContinuousInt64Enum.A.IsDefined().ShouldBeTrue();
        ContinuousInt64Enum.B.IsDefined().ShouldBeTrue();
        ContinuousInt64Enum.C.IsDefined().ShouldBeTrue();
        ((ContinuousInt64Enum)0).IsDefined().ShouldBeFalse();
        ((ContinuousInt64Enum)123).IsDefined().ShouldBeFalse();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<ContinuousInt64Enum>(nameof(ContinuousInt64Enum.A)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt64Enum>(nameof(ContinuousInt64Enum.B)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt64Enum>(nameof(ContinuousInt64Enum.C)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousInt64Enum>("0").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousInt64Enum>("123").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousInt64Enum>("value").ShouldBeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousInt64Enum.A, name: nameof(ContinuousInt64Enum.A)),
            (value: ContinuousInt64Enum.B, name: nameof(ContinuousInt64Enum.B)),
            (value: ContinuousInt64Enum.C, name: nameof(ContinuousInt64Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((long)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousInt64Enum>(x.name, ignoreCase).ShouldBe(x.value);
            Should.Throw<ArgumentException>(() => FastEnum.Parse<ContinuousInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase));
            FastEnum.Parse<ContinuousInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt64Enum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt64Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt64Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt64Enum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt64Enum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt64Enum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt64Enum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousInt64Enum>("123", ignoreCase).ShouldBe((ContinuousInt64Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousInt64Enum.A, name: nameof(ContinuousInt64Enum.A)),
            (value: ContinuousInt64Enum.B, name: nameof(ContinuousInt64Enum.B)),
            (value: ContinuousInt64Enum.C, name: nameof(ContinuousInt64Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((long)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousInt64Enum>(x.name, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt64Enum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt64Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousInt64Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt64Enum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt64Enum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt64Enum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousInt64Enum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousInt64Enum>("123", ignoreCase).ShouldBe((ContinuousInt64Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousInt64Enum.A, name: nameof(ContinuousInt64Enum.A)),
            (value: ContinuousInt64Enum.B, name: nameof(ContinuousInt64Enum.B)),
            (value: ContinuousInt64Enum.C, name: nameof(ContinuousInt64Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((long)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousInt64Enum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeFalse();
            FastEnum.TryParse<ContinuousInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeTrue();

            FastEnum.TryParse<ContinuousInt64Enum>(valueString, ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt64Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt64Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousInt64Enum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt64Enum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt64Enum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt64Enum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt64Enum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousInt64Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousInt64Enum.A, name: nameof(ContinuousInt64Enum.A)),
            (value: ContinuousInt64Enum.B, name: nameof(ContinuousInt64Enum.B)),
            (value: ContinuousInt64Enum.C, name: nameof(ContinuousInt64Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((long)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousInt64Enum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt64Enum>(valueString, ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt64Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r5).ShouldBeTrue();
            r5.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousInt64Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r6).ShouldBeTrue();
            r6.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousInt64Enum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt64Enum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt64Enum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt64Enum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousInt64Enum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousInt64Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        const ContinuousInt64Enum value = ContinuousInt64Enum.A;
        const string name = nameof(ContinuousInt64Enum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(ContinuousInt64Enum).GetField(name);

        member.ShouldNotBeNull();
        member.Name.ShouldBe(name);
        member.NameUtf8.ShouldBe(nameUtf8);
        member.Value.ShouldBe(value);
        member.FieldInfo.ShouldBe(info);
    }


    [TestMethod]
    public void ToName()
    {
        ContinuousInt64Enum.A.ToName().ShouldBe(nameof(ContinuousInt64Enum.A));
        ContinuousInt64Enum.B.ToName().ShouldBe(nameof(ContinuousInt64Enum.B));
        ContinuousInt64Enum.C.ToName().ShouldBe(nameof(ContinuousInt64Enum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        const ContinuousInt64Enum @enum = ContinuousInt64Enum.A;
        const long value = 1;

        Should.Throw<ArgumentException>(static () => @enum.ToSByte());
        Should.Throw<ArgumentException>(static () => @enum.ToByte());
        Should.Throw<ArgumentException>(static () => @enum.ToInt16());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt16());
        Should.Throw<ArgumentException>(static () => @enum.ToInt32());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt32());
        @enum.ToInt64().ShouldBe(value);
        Should.Throw<ArgumentException>(static () => @enum.ToUInt64());
    }


    [TestMethod]
    public void FastToString()
    {
        const ContinuousInt64Enum undefined = (ContinuousInt64Enum)123;
        var values = Enum.GetValues<ContinuousInt64Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.ShouldBe(expect);
        }
    }
}



[TestClass]
public sealed class ContinuousUInt64Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<ContinuousUInt64Enum>().ShouldBe(typeof(ulong));


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<ContinuousUInt64Enum>();
        var actual = FastEnum.GetValues<ContinuousUInt64Enum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<ContinuousUInt64Enum>();
        var actual = FastEnum.GetNames<ContinuousUInt64Enum>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousUInt64Enum>())
        {
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.ShouldNotBeNull();
            actual.ShouldBe(expect);
        }
        //--- undefined value
        {
            const ContinuousUInt64Enum undefined = (ContinuousUInt64Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.ShouldBeNull();
            actual.ShouldBe(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<ContinuousUInt64Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<ContinuousUInt64Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(ContinuousUInt64Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<ContinuousUInt64Enum>();

        actual.Length.ShouldBe(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.ShouldBe(e.value);
            a.Name.ShouldBe(e.name);
            a.NameUtf8.ShouldBe(e.nameUtf8);
            a.FieldInfo.ShouldBe(e.fieldInfo);

            var (name, value) = a;
            value.ShouldBe(e.value);
            name.ShouldBe(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<ContinuousUInt64Enum>())
        {
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.ShouldNotBeNull();
            actual.Value.ShouldBe(expect.value);
            actual.Name.ShouldBe(expect.name);
            actual.NameUtf8.ShouldBe(expect.nameUtf8);
            actual.FieldInfo.ShouldBe(expect.fieldInfo);

            var (name, value) = actual;
            value.ShouldBe(expect.value);
            name.ShouldBe(expect.name);
        }
        //--- undefined value
        {
            const ContinuousUInt64Enum undefined = (ContinuousUInt64Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.ShouldBeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<ContinuousUInt64Enum>();
        min.ShouldNotBeNull();
        min.ShouldBe(ContinuousUInt64Enum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<ContinuousUInt64Enum>();
        max.ShouldNotBeNull();
        max.ShouldBe(ContinuousUInt64Enum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<ContinuousUInt64Enum>().ShouldBe(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<ContinuousUInt64Enum>().ShouldBe(true);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<ContinuousUInt64Enum>().ShouldBe(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<ContinuousUInt64Enum>(ContinuousUInt64Enum.A).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt64Enum>(ContinuousUInt64Enum.B).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt64Enum>(ContinuousUInt64Enum.C).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt64Enum>((ContinuousUInt64Enum)0).ShouldBeFalse();
        FastEnum.IsDefined<ContinuousUInt64Enum>((ContinuousUInt64Enum)123).ShouldBeFalse();

        //--- Extension methods
        ContinuousUInt64Enum.A.IsDefined().ShouldBeTrue();
        ContinuousUInt64Enum.B.IsDefined().ShouldBeTrue();
        ContinuousUInt64Enum.C.IsDefined().ShouldBeTrue();
        ((ContinuousUInt64Enum)0).IsDefined().ShouldBeFalse();
        ((ContinuousUInt64Enum)123).IsDefined().ShouldBeFalse();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<ContinuousUInt64Enum>(nameof(ContinuousUInt64Enum.A)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt64Enum>(nameof(ContinuousUInt64Enum.B)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt64Enum>(nameof(ContinuousUInt64Enum.C)).ShouldBeTrue();
        FastEnum.IsDefined<ContinuousUInt64Enum>("0").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousUInt64Enum>("123").ShouldBeFalse();
        FastEnum.IsDefined<ContinuousUInt64Enum>("value").ShouldBeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousUInt64Enum.A, name: nameof(ContinuousUInt64Enum.A)),
            (value: ContinuousUInt64Enum.B, name: nameof(ContinuousUInt64Enum.B)),
            (value: ContinuousUInt64Enum.C, name: nameof(ContinuousUInt64Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((ulong)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousUInt64Enum>(x.name, ignoreCase).ShouldBe(x.value);
            Should.Throw<ArgumentException>(() => FastEnum.Parse<ContinuousUInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase));
            FastEnum.Parse<ContinuousUInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt64Enum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt64Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt64Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt64Enum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt64Enum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt64Enum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt64Enum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousUInt64Enum>("123", ignoreCase).ShouldBe((ContinuousUInt64Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousUInt64Enum.A, name: nameof(ContinuousUInt64Enum.A)),
            (value: ContinuousUInt64Enum.B, name: nameof(ContinuousUInt64Enum.B)),
            (value: ContinuousUInt64Enum.C, name: nameof(ContinuousUInt64Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((ulong)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<ContinuousUInt64Enum>(x.name, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt64Enum>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt64Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<ContinuousUInt64Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt64Enum>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt64Enum>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt64Enum>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<ContinuousUInt64Enum>("ABCDE", ignoreCase));
        FastEnum.Parse<ContinuousUInt64Enum>("123", ignoreCase).ShouldBe((ContinuousUInt64Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: ContinuousUInt64Enum.A, name: nameof(ContinuousUInt64Enum.A)),
            (value: ContinuousUInt64Enum.B, name: nameof(ContinuousUInt64Enum.B)),
            (value: ContinuousUInt64Enum.C, name: nameof(ContinuousUInt64Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((ulong)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousUInt64Enum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeFalse();
            FastEnum.TryParse<ContinuousUInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeTrue();

            FastEnum.TryParse<ContinuousUInt64Enum>(valueString, ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt64Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt64Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousUInt64Enum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt64Enum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt64Enum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt64Enum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt64Enum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousUInt64Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: ContinuousUInt64Enum.A, name: nameof(ContinuousUInt64Enum.A)),
            (value: ContinuousUInt64Enum.B, name: nameof(ContinuousUInt64Enum.B)),
            (value: ContinuousUInt64Enum.C, name: nameof(ContinuousUInt64Enum.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((ulong)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<ContinuousUInt64Enum>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt64Enum>(valueString, ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt64Enum>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r5).ShouldBeTrue();
            r5.ShouldBe(x.value);

            FastEnum.TryParse<ContinuousUInt64Enum>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r6).ShouldBeTrue();
            r6.ShouldBe(x.value);
        }
        FastEnum.TryParse<ContinuousUInt64Enum>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt64Enum>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt64Enum>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt64Enum>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<ContinuousUInt64Enum>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((ContinuousUInt64Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        const ContinuousUInt64Enum value = ContinuousUInt64Enum.A;
        const string name = nameof(ContinuousUInt64Enum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(ContinuousUInt64Enum).GetField(name);

        member.ShouldNotBeNull();
        member.Name.ShouldBe(name);
        member.NameUtf8.ShouldBe(nameUtf8);
        member.Value.ShouldBe(value);
        member.FieldInfo.ShouldBe(info);
    }


    [TestMethod]
    public void ToName()
    {
        ContinuousUInt64Enum.A.ToName().ShouldBe(nameof(ContinuousUInt64Enum.A));
        ContinuousUInt64Enum.B.ToName().ShouldBe(nameof(ContinuousUInt64Enum.B));
        ContinuousUInt64Enum.C.ToName().ShouldBe(nameof(ContinuousUInt64Enum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        const ContinuousUInt64Enum @enum = ContinuousUInt64Enum.A;
        const ulong value = 1;

        Should.Throw<ArgumentException>(static () => @enum.ToSByte());
        Should.Throw<ArgumentException>(static () => @enum.ToByte());
        Should.Throw<ArgumentException>(static () => @enum.ToInt16());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt16());
        Should.Throw<ArgumentException>(static () => @enum.ToInt32());
        Should.Throw<ArgumentException>(static () => @enum.ToUInt32());
        Should.Throw<ArgumentException>(static () => @enum.ToInt64());
        @enum.ToUInt64().ShouldBe(value);
    }


    [TestMethod]
    public void FastToString()
    {
        const ContinuousUInt64Enum undefined = (ContinuousUInt64Enum)123;
        var values = Enum.GetValues<ContinuousUInt64Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.ShouldBe(expect);
        }
    }
}



