<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var parameters = new[]
    {
        new { EnumType = "DiscontinuousSByteEnum",  UnderlyingType = "sbyte",  AliasType = "SByte",  ConjugateType = "byte",   IsSignedType = true  },
        new { EnumType = "DiscontinuousByteEnum",   UnderlyingType = "byte",   AliasType = "Byte",   ConjugateType = "sbyte",  IsSignedType = false },
        new { EnumType = "DiscontinuousInt16Enum",  UnderlyingType = "short",  AliasType = "Int16",  ConjugateType = "ushort", IsSignedType = true  },
        new { EnumType = "DiscontinuousUInt16Enum", UnderlyingType = "ushort", AliasType = "UInt16", ConjugateType = "short",  IsSignedType = false },
        new { EnumType = "DiscontinuousInt32Enum",  UnderlyingType = "int",    AliasType = "Int32",  ConjugateType = "uint",   IsSignedType = true  },
        new { EnumType = "DiscontinuousUInt32Enum", UnderlyingType = "uint",   AliasType = "UInt32", ConjugateType = "int",    IsSignedType = false },
        new { EnumType = "DiscontinuousInt64Enum",  UnderlyingType = "long",   AliasType = "Int64",  ConjugateType = "ulong",  IsSignedType = true  },
        new { EnumType = "DiscontinuousUInt64Enum", UnderlyingType = "ulong",  AliasType = "UInt64", ConjugateType = "long",   IsSignedType = false },
    };
#>
// <auto-generated>
// This .cs file is generated by T4 template. Don't change it. Change the .tt file instead.
// </auto-generated>
#nullable enable

using System;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using FastEnumUtility.UnitTests.Models;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Shouldly;

namespace FastEnumUtility.UnitTests.Cases.Reflections;



<# foreach (var x in parameters) { #>
[TestClass]
public sealed class Discontinuous<#= x.AliasType #>Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<<#= x.EnumType #>>().ShouldBe(typeof(<#= x.UnderlyingType #>));


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<<#= x.EnumType #>>();
        var actual = FastEnum.GetValues<<#= x.EnumType #>>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<<#= x.EnumType #>>();
        var actual = FastEnum.GetNames<<#= x.EnumType #>>();
        actual.ShouldBe(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<<#= x.EnumType #>>())
        {
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.ShouldNotBeNull();
            actual.ShouldBe(expect);
        }
        //--- undefined value
        {
            const <#= x.EnumType #> undefined = (<#= x.EnumType #>)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.ShouldBeNull();
            actual.ShouldBe(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<<#= x.EnumType #>>()
            .Select(static name =>
            {
                var value = Enum.Parse<<#= x.EnumType #>>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(<#= x.EnumType #>).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<<#= x.EnumType #>>();

        actual.Length.ShouldBe(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.ShouldBe(e.value);
            a.Name.ShouldBe(e.name);
            a.NameUtf8.ShouldBe(e.nameUtf8);
            a.FieldInfo.ShouldBe(e.fieldInfo);

            var (name, value) = a;
            value.ShouldBe(e.value);
            name.ShouldBe(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        foreach (var defined in Enum.GetValues<<#= x.EnumType #>>())
        {
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.ShouldNotBeNull();
            actual.Value.ShouldBe(expect.value);
            actual.Name.ShouldBe(expect.name);
            actual.NameUtf8.ShouldBe(expect.nameUtf8);
            actual.FieldInfo.ShouldBe(expect.fieldInfo);

            var (name, value) = actual;
            value.ShouldBe(expect.value);
            name.ShouldBe(expect.name);
        }
        //--- undefined value
        {
            const <#= x.EnumType #> undefined = (<#= x.EnumType #>)123;
            var actual = FastEnum.GetMember(undefined);
            actual.ShouldBeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<<#= x.EnumType #>>();
        min.ShouldNotBeNull();
        min.ShouldBe(<#= x.EnumType #>.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<<#= x.EnumType #>>();
        max.ShouldNotBeNull();
        max.ShouldBe(<#= x.EnumType #>.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<<#= x.EnumType #>>().ShouldBe(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<<#= x.EnumType #>>().ShouldBe(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<<#= x.EnumType #>>().ShouldBe(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<<#= x.EnumType #>>(<#= x.EnumType #>.A).ShouldBeTrue();
        FastEnum.IsDefined<<#= x.EnumType #>>(<#= x.EnumType #>.B).ShouldBeTrue();
        FastEnum.IsDefined<<#= x.EnumType #>>(<#= x.EnumType #>.C).ShouldBeTrue();
        FastEnum.IsDefined<<#= x.EnumType #>>((<#= x.EnumType #>)123).ShouldBeFalse();

        //--- Extension methods
        <#= x.EnumType #>.A.IsDefined().ShouldBeTrue();
        <#= x.EnumType #>.B.IsDefined().ShouldBeTrue();
        <#= x.EnumType #>.C.IsDefined().ShouldBeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<<#= x.EnumType #>>(nameof(<#= x.EnumType #>.A)).ShouldBeTrue();
        FastEnum.IsDefined<<#= x.EnumType #>>(nameof(<#= x.EnumType #>.B)).ShouldBeTrue();
        FastEnum.IsDefined<<#= x.EnumType #>>(nameof(<#= x.EnumType #>.C)).ShouldBeTrue();
        FastEnum.IsDefined<<#= x.EnumType #>>("123").ShouldBeFalse();
        FastEnum.IsDefined<<#= x.EnumType #>>("value").ShouldBeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: <#= x.EnumType #>.A, name: nameof(<#= x.EnumType #>.A)),
            (value: <#= x.EnumType #>.B, name: nameof(<#= x.EnumType #>.B)),
            (value: <#= x.EnumType #>.C, name: nameof(<#= x.EnumType #>.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((<#= x.UnderlyingType #>)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<<#= x.EnumType #>>(x.name, ignoreCase).ShouldBe(x.value);
            Should.Throw<ArgumentException>(() => FastEnum.Parse<<#= x.EnumType #>>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase));
            FastEnum.Parse<<#= x.EnumType #>>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<<#= x.EnumType #>>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<<#= x.EnumType #>>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<<#= x.EnumType #>>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<<#= x.EnumType #>>("ABCDE", ignoreCase));
        FastEnum.Parse<<#= x.EnumType #>>("123", ignoreCase).ShouldBe((<#= x.EnumType #>)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: <#= x.EnumType #>.A, name: nameof(<#= x.EnumType #>.A)),
            (value: <#= x.EnumType #>.B, name: nameof(<#= x.EnumType #>.B)),
            (value: <#= x.EnumType #>.C, name: nameof(<#= x.EnumType #>.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((<#= x.UnderlyingType #>)x.value).ToString(CultureInfo.InvariantCulture);
            FastEnum.Parse<<#= x.EnumType #>>(x.name, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(valueString, ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase).ShouldBe(x.value);
        }
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<<#= x.EnumType #>>((string?)null, ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<<#= x.EnumType #>>("", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<<#= x.EnumType #>>(" ", ignoreCase));
        Should.Throw<ArgumentException>(static () => FastEnum.Parse<<#= x.EnumType #>>("ABCDE", ignoreCase));
        FastEnum.Parse<<#= x.EnumType #>>("123", ignoreCase).ShouldBe((<#= x.EnumType #>)123);
    }


    [TestMethod]
    public void TryParse()
    {
        const bool ignoreCase = false;
        var parameters = new[]
        {
            (value: <#= x.EnumType #>.A, name: nameof(<#= x.EnumType #>.A)),
            (value: <#= x.EnumType #>.B, name: nameof(<#= x.EnumType #>.B)),
            (value: <#= x.EnumType #>.C, name: nameof(<#= x.EnumType #>.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((<#= x.UnderlyingType #>)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<<#= x.EnumType #>>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeFalse();
            FastEnum.TryParse<<#= x.EnumType #>>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var _).ShouldBeTrue();

            FastEnum.TryParse<<#= x.EnumType #>>(valueString, ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);
        }
        FastEnum.TryParse<<#= x.EnumType #>>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((<#= x.EnumType #>)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        const bool ignoreCase = true;
        var parameters = new[]
        {
            (value: <#= x.EnumType #>.A, name: nameof(<#= x.EnumType #>.A)),
            (value: <#= x.EnumType #>.B, name: nameof(<#= x.EnumType #>.B)),
            (value: <#= x.EnumType #>.C, name: nameof(<#= x.EnumType #>.C)),
        };
        foreach (var x in parameters)
        {
            var valueString = ((<#= x.UnderlyingType #>)x.value).ToString(CultureInfo.InvariantCulture);

            FastEnum.TryParse<<#= x.EnumType #>>(x.name, ignoreCase, out var r1).ShouldBeTrue();
            r1.ShouldBe(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(x.name.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r2).ShouldBeTrue();
            r2.ShouldBe(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(x.name.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r3).ShouldBeTrue();
            r3.ShouldBe(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(valueString, ignoreCase, out var r4).ShouldBeTrue();
            r4.ShouldBe(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(valueString.ToLower(CultureInfo.InvariantCulture), ignoreCase, out var r5).ShouldBeTrue();
            r5.ShouldBe(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(valueString.ToUpper(CultureInfo.InvariantCulture), ignoreCase, out var r6).ShouldBeTrue();
            r6.ShouldBe(x.value);
        }
        FastEnum.TryParse<<#= x.EnumType #>>((string?)null, ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>("", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>(" ", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>("ABCDE", ignoreCase, out var _).ShouldBeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>("123", ignoreCase, out var r).ShouldBeTrue();
        r.ShouldBe((<#= x.EnumType #>)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = <#= x.EnumType #>.A;
        var name = nameof(<#= x.EnumType #>.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(<#= x.EnumType #>).GetField(name);

        member.ShouldNotBeNull();
        member.Name.ShouldBe(name);
        member.NameUtf8.ShouldBe(nameUtf8);
        member.Value.ShouldBe(value);
        member.FieldInfo.ShouldBe(info);
    }


    [TestMethod]
    public void ToName()
    {
        <#= x.EnumType #>.A.ToName().ShouldBe(nameof(<#= x.EnumType #>.A));
        <#= x.EnumType #>.B.ToName().ShouldBe(nameof(<#= x.EnumType #>.B));
        <#= x.EnumType #>.C.ToName().ShouldBe(nameof(<#= x.EnumType #>.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = <#= x.EnumType #>.A;
        const <#= x.UnderlyingType #> value = 1;

<# foreach (var y in parameters) { #>
<# if (x.EnumType == y.EnumType) { #>
        @enum.To<#= y.AliasType #>().ShouldBe(value);
<# } else { #>
        Should.Throw<ArgumentException>(() => @enum.To<#= y.AliasType #>());
<# } #>
<# } #>
    }


    [TestMethod]
    public void FastToString()
    {
        const <#= x.EnumType #> undefined = (<#= x.EnumType #>)123;
        var values = Enum.GetValues<<#= x.EnumType #>>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.ShouldBe(expect);
        }
    }
}



<# } #>
