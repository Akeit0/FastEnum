<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var parameters = new[]
    {
        new { EnumType = "SameValueContinuousEnum",    UnderlyingType = "byte", AliasType = "Byte", ConjugateType = "sbyte", IsContinuous = true },
        new { EnumType = "SameValueDiscontinuousEnum", UnderlyingType = "byte", AliasType = "Byte", ConjugateType = "sbyte", IsContinuous = false },
    };
#>
// <auto-generated>
// This .cs file is generated by T4 template. Don't change it. Change the .tt file instead.
// </auto-generated>
#nullable enable

using System;
using System.Globalization;
using System.Linq;
using System.Text;
using FastEnumUtility.UnitTests.Models;
using FluentAssertions;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace FastEnumUtility.UnitTests.Cases.Reflections;



<# foreach (var x in parameters) { #>
[TestClass]
public sealed class SameValue<#= x.IsContinuous ? "Continuous" : "Discontinuous" #>Tests
{
    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<<#= x.EnumType #>>();
        var actual = FastEnum.GetValues<<#= x.EnumType #>>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames(typeof(<#= x.EnumType #>));
        var actual = FastEnum.GetNames<<#= x.EnumType #>>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<<#= x.EnumType #>>()
            .Select(static name =>
            {
                var value = Enum.Parse<<#= x.EnumType #>>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(<#= x.EnumType #>).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<<#= x.EnumType #>>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined(<#= x.EnumType #>.A).Should().BeTrue();
        FastEnum.IsDefined(<#= x.EnumType #>.B).Should().BeTrue();
        FastEnum.IsDefined(<#= x.EnumType #>.C).Should().BeTrue();
        FastEnum.IsDefined(<#= x.EnumType #>.D).Should().BeTrue();
        FastEnum.IsDefined((<#= x.EnumType #>)123).Should().BeFalse();

        //--- Extension methods
        <#= x.EnumType #>.A.IsDefined().Should().BeTrue();
        <#= x.EnumType #>.B.IsDefined().Should().BeTrue();
        <#= x.EnumType #>.C.IsDefined().Should().BeTrue();
        <#= x.EnumType #>.D.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<<#= x.EnumType #>>(nameof(<#= x.EnumType #>.A)).Should().BeTrue();
        FastEnum.IsDefined<<#= x.EnumType #>>(nameof(<#= x.EnumType #>.B)).Should().BeTrue();
        FastEnum.IsDefined<<#= x.EnumType #>>(nameof(<#= x.EnumType #>.C)).Should().BeTrue();
        FastEnum.IsDefined<<#= x.EnumType #>>(nameof(<#= x.EnumType #>.D)).Should().BeTrue();
        FastEnum.IsDefined<<#= x.EnumType #>>("123").Should().BeFalse();
        FastEnum.IsDefined<<#= x.EnumType #>>("value").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: <#= x.EnumType #>.A, name: nameof(<#= x.EnumType #>.A), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.A).ToString(CultureInfo.InvariantCulture)),
            (value: <#= x.EnumType #>.B, name: nameof(<#= x.EnumType #>.B), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.B).ToString(CultureInfo.InvariantCulture)),
            (value: <#= x.EnumType #>.C, name: nameof(<#= x.EnumType #>.C), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.C).ToString(CultureInfo.InvariantCulture)),
            (value: <#= x.EnumType #>.D, name: nameof(<#= x.EnumType #>.D), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.D).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<<#= x.EnumType #>>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<<#= x.EnumType #>>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<<#= x.EnumType #>>(x.name.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>>((string?)null)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<<#= x.EnumType #>>("123").Should().Be((<#= x.EnumType #>)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: <#= x.EnumType #>.A, name: nameof(<#= x.EnumType #>.A), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.A).ToString(CultureInfo.InvariantCulture)),
            (value: <#= x.EnumType #>.B, name: nameof(<#= x.EnumType #>.B), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.B).ToString(CultureInfo.InvariantCulture)),
            (value: <#= x.EnumType #>.C, name: nameof(<#= x.EnumType #>.C), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.C).ToString(CultureInfo.InvariantCulture)),
            (value: <#= x.EnumType #>.D, name: nameof(<#= x.EnumType #>.D), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.D).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<<#= x.EnumType #>>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(x.valueString, true).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<<#= x.EnumType #>>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<<#= x.EnumType #>>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<<#= x.EnumType #>>("123", true).Should().Be((<#= x.EnumType #>)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: <#= x.EnumType #>.A, name: nameof(<#= x.EnumType #>.A), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.A).ToString(CultureInfo.InvariantCulture)),
            (value: <#= x.EnumType #>.B, name: nameof(<#= x.EnumType #>.B), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.B).ToString(CultureInfo.InvariantCulture)),
            (value: <#= x.EnumType #>.C, name: nameof(<#= x.EnumType #>.C), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.C).ToString(CultureInfo.InvariantCulture)),
            (value: <#= x.EnumType #>.D, name: nameof(<#= x.EnumType #>.D), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.D).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<<#= x.EnumType #>>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<<#= x.EnumType #>>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeTrue();

            FastEnum.TryParse<<#= x.EnumType #>>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<<#= x.EnumType #>>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>("", out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>("123", out var r).Should().BeTrue();
        r.Should().Be((<#= x.EnumType #>)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: <#= x.EnumType #>.A, name: nameof(<#= x.EnumType #>.A), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.A).ToString(CultureInfo.InvariantCulture)),
            (value: <#= x.EnumType #>.B, name: nameof(<#= x.EnumType #>.B), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.B).ToString(CultureInfo.InvariantCulture)),
            (value: <#= x.EnumType #>.C, name: nameof(<#= x.EnumType #>.C), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.C).ToString(CultureInfo.InvariantCulture)),
            (value: <#= x.EnumType #>.D, name: nameof(<#= x.EnumType #>.D), valueString: ((<#= x.UnderlyingType #>)<#= x.EnumType #>.D).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<<#= x.EnumType #>>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<<#= x.EnumType #>>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<<#= x.EnumType #>>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<<#= x.EnumType #>>("123", true, out var r).Should().BeTrue();
        r.Should().Be((<#= x.EnumType #>)123);
    }


    [TestMethod]
    public void ToMember()
    {
        {
            var value = <#= x.EnumType #>.A;
            var name = nameof(<#= x.EnumType #>.A);
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var member = value.ToMember()!;
            var info = typeof(<#= x.EnumType #>).GetField(name);

            member.Should().NotBeNull();
            member.Name.Should().Be(name);
            member.NameUtf8.Should().Equal(nameUtf8);
            member.Value.Should().Be(value);
            member.FieldInfo.Should().Be(info);
        }
        {
            var value = <#= x.EnumType #>.B;
            var name = nameof(<#= x.EnumType #>.B);  // If the same value exists, we can't control what is correct.
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var member = value.ToMember()!;
            var info = typeof(<#= x.EnumType #>).GetField(name);

            member.Should().NotBeNull();
            member.Name.Should().Be(name);
            member.NameUtf8.Should().Equal(nameUtf8);
            member.Value.Should().Be(value);
            member.FieldInfo.Should().Be(info);
        }
        {
            var value = <#= x.EnumType #>.C;
            var name = nameof(<#= x.EnumType #>.B);  // If the same value exists, we can't control what is correct.
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var member = value.ToMember()!;
            var info = typeof(<#= x.EnumType #>).GetField(name);

            member.Should().NotBeNull();
            member.Name.Should().Be(name);
            member.NameUtf8.Should().Equal(nameUtf8);
            member.Value.Should().Be(value);
            member.FieldInfo.Should().Be(info);
        }
        {
            var value = <#= x.EnumType #>.D;
            var name = nameof(<#= x.EnumType #>.D);
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var member = value.ToMember()!;
            var info = typeof(<#= x.EnumType #>).GetField(name);

            member.Should().NotBeNull();
            member.Name.Should().Be(name);
            member.NameUtf8.Should().Equal(nameUtf8);
            member.Value.Should().Be(value);
            member.FieldInfo.Should().Be(info);
        }
    }


    [TestMethod]
    public void ToName()
    {
        var values = Enum.GetValues<<#= x.EnumType #>>();
        foreach (var x in values)
        {
            var expect = Enum.GetName(x);
            var actual = x.ToName();
            actual.Should().Be(expect);
        }
    }


    [TestMethod]
    public void FastToString()
    {
        var values = Enum.GetValues<<#= x.EnumType #>>();
        foreach (var x in values)
        {
            var expect = Enum.GetName(x);
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



<# } #>
