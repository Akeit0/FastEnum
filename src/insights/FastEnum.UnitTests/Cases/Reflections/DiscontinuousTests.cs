// <auto-generated>
// This .cs file is generated by T4 template. Don't change it. Change the .tt file instead.
// </auto-generated>
#nullable enable

using System;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using FastEnumUtility.UnitTests.Models;
using FluentAssertions;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace FastEnumUtility.UnitTests.Cases.Reflections;



[TestClass]
public sealed class DiscontinuousSByteTests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<DiscontinuousSByteEnum>().Should().Be<sbyte>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<DiscontinuousSByteEnum>();
        var actual = FastEnum.GetValues<DiscontinuousSByteEnum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<DiscontinuousSByteEnum>();
        var actual = FastEnum.GetNames<DiscontinuousSByteEnum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const DiscontinuousSByteEnum defined = DiscontinuousSByteEnum.A;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().Be(expect);
        }
        //--- undefined value
        {
            const DiscontinuousSByteEnum undefined = (DiscontinuousSByteEnum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().Be(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<DiscontinuousSByteEnum>()
            .Select(static name =>
            {
                var value = Enum.Parse<DiscontinuousSByteEnum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(DiscontinuousSByteEnum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<DiscontinuousSByteEnum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const DiscontinuousSByteEnum defined = DiscontinuousSByteEnum.A;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const DiscontinuousSByteEnum undefined = (DiscontinuousSByteEnum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<DiscontinuousSByteEnum>();
        min.Should().NotBeNull();
        min.Should().Be(DiscontinuousSByteEnum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<DiscontinuousSByteEnum>();
        max.Should().NotBeNull();
        max.Should().Be(DiscontinuousSByteEnum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<DiscontinuousSByteEnum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<DiscontinuousSByteEnum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<DiscontinuousSByteEnum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<DiscontinuousSByteEnum>(DiscontinuousSByteEnum.A).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousSByteEnum>(DiscontinuousSByteEnum.B).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousSByteEnum>(DiscontinuousSByteEnum.C).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousSByteEnum>((DiscontinuousSByteEnum)123).Should().BeFalse();

        //--- Extension methods
        DiscontinuousSByteEnum.A.IsDefined().Should().BeTrue();
        DiscontinuousSByteEnum.B.IsDefined().Should().BeTrue();
        DiscontinuousSByteEnum.C.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<DiscontinuousSByteEnum>(nameof(DiscontinuousSByteEnum.A)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousSByteEnum>(nameof(DiscontinuousSByteEnum.B)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousSByteEnum>(nameof(DiscontinuousSByteEnum.C)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousSByteEnum>("123").Should().BeFalse();
        FastEnum.IsDefined<DiscontinuousSByteEnum>("value").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousSByteEnum.A, name: nameof(DiscontinuousSByteEnum.A), valueString: ((sbyte)DiscontinuousSByteEnum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousSByteEnum.B, name: nameof(DiscontinuousSByteEnum.B), valueString: ((sbyte)DiscontinuousSByteEnum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousSByteEnum.C, name: nameof(DiscontinuousSByteEnum.C), valueString: ((sbyte)DiscontinuousSByteEnum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousSByteEnum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<DiscontinuousSByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<DiscontinuousSByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousSByteEnum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousSByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousSByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousSByteEnum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousSByteEnum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousSByteEnum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousSByteEnum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousSByteEnum>("123").Should().Be((DiscontinuousSByteEnum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousSByteEnum.A, name: nameof(DiscontinuousSByteEnum.A), valueString: ((sbyte)DiscontinuousSByteEnum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousSByteEnum.B, name: nameof(DiscontinuousSByteEnum.B), valueString: ((sbyte)DiscontinuousSByteEnum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousSByteEnum.C, name: nameof(DiscontinuousSByteEnum.C), valueString: ((sbyte)DiscontinuousSByteEnum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousSByteEnum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousSByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousSByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousSByteEnum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousSByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousSByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousSByteEnum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousSByteEnum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousSByteEnum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousSByteEnum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousSByteEnum>("123").Should().Be((DiscontinuousSByteEnum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousSByteEnum.A, name: nameof(DiscontinuousSByteEnum.A), valueString: ((sbyte)DiscontinuousSByteEnum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousSByteEnum.B, name: nameof(DiscontinuousSByteEnum.B), valueString: ((sbyte)DiscontinuousSByteEnum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousSByteEnum.C, name: nameof(DiscontinuousSByteEnum.C), valueString: ((sbyte)DiscontinuousSByteEnum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousSByteEnum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousSByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<DiscontinuousSByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeTrue();

            FastEnum.TryParse<DiscontinuousSByteEnum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousSByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousSByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousSByteEnum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousSByteEnum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousSByteEnum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousSByteEnum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousSByteEnum>("123", out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousSByteEnum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousSByteEnum.A, name: nameof(DiscontinuousSByteEnum.A), valueString: ((sbyte)DiscontinuousSByteEnum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousSByteEnum.B, name: nameof(DiscontinuousSByteEnum.B), valueString: ((sbyte)DiscontinuousSByteEnum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousSByteEnum.C, name: nameof(DiscontinuousSByteEnum.C), valueString: ((sbyte)DiscontinuousSByteEnum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousSByteEnum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousSByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousSByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousSByteEnum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousSByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousSByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousSByteEnum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousSByteEnum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousSByteEnum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousSByteEnum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousSByteEnum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousSByteEnum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = DiscontinuousSByteEnum.A;
        var name = nameof(DiscontinuousSByteEnum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(DiscontinuousSByteEnum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        DiscontinuousSByteEnum.A.ToName().Should().Be(nameof(DiscontinuousSByteEnum.A));
        DiscontinuousSByteEnum.B.ToName().Should().Be(nameof(DiscontinuousSByteEnum.B));
        DiscontinuousSByteEnum.C.ToName().Should().Be(nameof(DiscontinuousSByteEnum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = DiscontinuousSByteEnum.A;
        const sbyte value = 1;

        @enum.ToSByte().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const DiscontinuousSByteEnum undefined = (DiscontinuousSByteEnum)123;
        var values = Enum.GetValues<DiscontinuousSByteEnum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



[TestClass]
public sealed class DiscontinuousByteTests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<DiscontinuousByteEnum>().Should().Be<byte>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<DiscontinuousByteEnum>();
        var actual = FastEnum.GetValues<DiscontinuousByteEnum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<DiscontinuousByteEnum>();
        var actual = FastEnum.GetNames<DiscontinuousByteEnum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const DiscontinuousByteEnum defined = DiscontinuousByteEnum.A;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().Be(expect);
        }
        //--- undefined value
        {
            const DiscontinuousByteEnum undefined = (DiscontinuousByteEnum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().Be(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<DiscontinuousByteEnum>()
            .Select(static name =>
            {
                var value = Enum.Parse<DiscontinuousByteEnum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(DiscontinuousByteEnum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<DiscontinuousByteEnum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const DiscontinuousByteEnum defined = DiscontinuousByteEnum.A;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const DiscontinuousByteEnum undefined = (DiscontinuousByteEnum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<DiscontinuousByteEnum>();
        min.Should().NotBeNull();
        min.Should().Be(DiscontinuousByteEnum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<DiscontinuousByteEnum>();
        max.Should().NotBeNull();
        max.Should().Be(DiscontinuousByteEnum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<DiscontinuousByteEnum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<DiscontinuousByteEnum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<DiscontinuousByteEnum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<DiscontinuousByteEnum>(DiscontinuousByteEnum.A).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousByteEnum>(DiscontinuousByteEnum.B).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousByteEnum>(DiscontinuousByteEnum.C).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousByteEnum>((DiscontinuousByteEnum)123).Should().BeFalse();

        //--- Extension methods
        DiscontinuousByteEnum.A.IsDefined().Should().BeTrue();
        DiscontinuousByteEnum.B.IsDefined().Should().BeTrue();
        DiscontinuousByteEnum.C.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<DiscontinuousByteEnum>(nameof(DiscontinuousByteEnum.A)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousByteEnum>(nameof(DiscontinuousByteEnum.B)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousByteEnum>(nameof(DiscontinuousByteEnum.C)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousByteEnum>("123").Should().BeFalse();
        FastEnum.IsDefined<DiscontinuousByteEnum>("value").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousByteEnum.A, name: nameof(DiscontinuousByteEnum.A), valueString: ((byte)DiscontinuousByteEnum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousByteEnum.B, name: nameof(DiscontinuousByteEnum.B), valueString: ((byte)DiscontinuousByteEnum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousByteEnum.C, name: nameof(DiscontinuousByteEnum.C), valueString: ((byte)DiscontinuousByteEnum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousByteEnum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<DiscontinuousByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<DiscontinuousByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousByteEnum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousByteEnum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousByteEnum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousByteEnum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousByteEnum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousByteEnum>("123").Should().Be((DiscontinuousByteEnum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousByteEnum.A, name: nameof(DiscontinuousByteEnum.A), valueString: ((byte)DiscontinuousByteEnum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousByteEnum.B, name: nameof(DiscontinuousByteEnum.B), valueString: ((byte)DiscontinuousByteEnum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousByteEnum.C, name: nameof(DiscontinuousByteEnum.C), valueString: ((byte)DiscontinuousByteEnum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousByteEnum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousByteEnum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousByteEnum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousByteEnum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousByteEnum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousByteEnum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousByteEnum>("123").Should().Be((DiscontinuousByteEnum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousByteEnum.A, name: nameof(DiscontinuousByteEnum.A), valueString: ((byte)DiscontinuousByteEnum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousByteEnum.B, name: nameof(DiscontinuousByteEnum.B), valueString: ((byte)DiscontinuousByteEnum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousByteEnum.C, name: nameof(DiscontinuousByteEnum.C), valueString: ((byte)DiscontinuousByteEnum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousByteEnum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<DiscontinuousByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeTrue();

            FastEnum.TryParse<DiscontinuousByteEnum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousByteEnum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousByteEnum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousByteEnum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousByteEnum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousByteEnum>("123", out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousByteEnum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousByteEnum.A, name: nameof(DiscontinuousByteEnum.A), valueString: ((byte)DiscontinuousByteEnum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousByteEnum.B, name: nameof(DiscontinuousByteEnum.B), valueString: ((byte)DiscontinuousByteEnum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousByteEnum.C, name: nameof(DiscontinuousByteEnum.C), valueString: ((byte)DiscontinuousByteEnum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousByteEnum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousByteEnum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousByteEnum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousByteEnum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousByteEnum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousByteEnum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousByteEnum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousByteEnum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousByteEnum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousByteEnum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousByteEnum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousByteEnum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = DiscontinuousByteEnum.A;
        var name = nameof(DiscontinuousByteEnum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(DiscontinuousByteEnum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        DiscontinuousByteEnum.A.ToName().Should().Be(nameof(DiscontinuousByteEnum.A));
        DiscontinuousByteEnum.B.ToName().Should().Be(nameof(DiscontinuousByteEnum.B));
        DiscontinuousByteEnum.C.ToName().Should().Be(nameof(DiscontinuousByteEnum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = DiscontinuousByteEnum.A;
        const byte value = 1;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        @enum.ToByte().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const DiscontinuousByteEnum undefined = (DiscontinuousByteEnum)123;
        var values = Enum.GetValues<DiscontinuousByteEnum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



[TestClass]
public sealed class DiscontinuousInt16Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<DiscontinuousInt16Enum>().Should().Be<short>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<DiscontinuousInt16Enum>();
        var actual = FastEnum.GetValues<DiscontinuousInt16Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<DiscontinuousInt16Enum>();
        var actual = FastEnum.GetNames<DiscontinuousInt16Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const DiscontinuousInt16Enum defined = DiscontinuousInt16Enum.A;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().Be(expect);
        }
        //--- undefined value
        {
            const DiscontinuousInt16Enum undefined = (DiscontinuousInt16Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().Be(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<DiscontinuousInt16Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<DiscontinuousInt16Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(DiscontinuousInt16Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<DiscontinuousInt16Enum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const DiscontinuousInt16Enum defined = DiscontinuousInt16Enum.A;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const DiscontinuousInt16Enum undefined = (DiscontinuousInt16Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<DiscontinuousInt16Enum>();
        min.Should().NotBeNull();
        min.Should().Be(DiscontinuousInt16Enum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<DiscontinuousInt16Enum>();
        max.Should().NotBeNull();
        max.Should().Be(DiscontinuousInt16Enum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<DiscontinuousInt16Enum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<DiscontinuousInt16Enum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<DiscontinuousInt16Enum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<DiscontinuousInt16Enum>(DiscontinuousInt16Enum.A).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt16Enum>(DiscontinuousInt16Enum.B).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt16Enum>(DiscontinuousInt16Enum.C).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt16Enum>((DiscontinuousInt16Enum)123).Should().BeFalse();

        //--- Extension methods
        DiscontinuousInt16Enum.A.IsDefined().Should().BeTrue();
        DiscontinuousInt16Enum.B.IsDefined().Should().BeTrue();
        DiscontinuousInt16Enum.C.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<DiscontinuousInt16Enum>(nameof(DiscontinuousInt16Enum.A)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt16Enum>(nameof(DiscontinuousInt16Enum.B)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt16Enum>(nameof(DiscontinuousInt16Enum.C)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt16Enum>("123").Should().BeFalse();
        FastEnum.IsDefined<DiscontinuousInt16Enum>("value").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousInt16Enum.A, name: nameof(DiscontinuousInt16Enum.A), valueString: ((short)DiscontinuousInt16Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt16Enum.B, name: nameof(DiscontinuousInt16Enum.B), valueString: ((short)DiscontinuousInt16Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt16Enum.C, name: nameof(DiscontinuousInt16Enum.C), valueString: ((short)DiscontinuousInt16Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousInt16Enum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<DiscontinuousInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<DiscontinuousInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt16Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt16Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt16Enum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt16Enum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt16Enum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousInt16Enum>("123").Should().Be((DiscontinuousInt16Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousInt16Enum.A, name: nameof(DiscontinuousInt16Enum.A), valueString: ((short)DiscontinuousInt16Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt16Enum.B, name: nameof(DiscontinuousInt16Enum.B), valueString: ((short)DiscontinuousInt16Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt16Enum.C, name: nameof(DiscontinuousInt16Enum.C), valueString: ((short)DiscontinuousInt16Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousInt16Enum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt16Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt16Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt16Enum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt16Enum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt16Enum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousInt16Enum>("123").Should().Be((DiscontinuousInt16Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousInt16Enum.A, name: nameof(DiscontinuousInt16Enum.A), valueString: ((short)DiscontinuousInt16Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt16Enum.B, name: nameof(DiscontinuousInt16Enum.B), valueString: ((short)DiscontinuousInt16Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt16Enum.C, name: nameof(DiscontinuousInt16Enum.C), valueString: ((short)DiscontinuousInt16Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousInt16Enum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<DiscontinuousInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeTrue();

            FastEnum.TryParse<DiscontinuousInt16Enum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousInt16Enum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt16Enum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt16Enum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt16Enum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt16Enum>("123", out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousInt16Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousInt16Enum.A, name: nameof(DiscontinuousInt16Enum.A), valueString: ((short)DiscontinuousInt16Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt16Enum.B, name: nameof(DiscontinuousInt16Enum.B), valueString: ((short)DiscontinuousInt16Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt16Enum.C, name: nameof(DiscontinuousInt16Enum.C), valueString: ((short)DiscontinuousInt16Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousInt16Enum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt16Enum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousInt16Enum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt16Enum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt16Enum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt16Enum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt16Enum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousInt16Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = DiscontinuousInt16Enum.A;
        var name = nameof(DiscontinuousInt16Enum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(DiscontinuousInt16Enum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        DiscontinuousInt16Enum.A.ToName().Should().Be(nameof(DiscontinuousInt16Enum.A));
        DiscontinuousInt16Enum.B.ToName().Should().Be(nameof(DiscontinuousInt16Enum.B));
        DiscontinuousInt16Enum.C.ToName().Should().Be(nameof(DiscontinuousInt16Enum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = DiscontinuousInt16Enum.A;
        const short value = 1;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        @enum.ToInt16().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const DiscontinuousInt16Enum undefined = (DiscontinuousInt16Enum)123;
        var values = Enum.GetValues<DiscontinuousInt16Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



[TestClass]
public sealed class DiscontinuousUInt16Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<DiscontinuousUInt16Enum>().Should().Be<ushort>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<DiscontinuousUInt16Enum>();
        var actual = FastEnum.GetValues<DiscontinuousUInt16Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<DiscontinuousUInt16Enum>();
        var actual = FastEnum.GetNames<DiscontinuousUInt16Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const DiscontinuousUInt16Enum defined = DiscontinuousUInt16Enum.A;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().Be(expect);
        }
        //--- undefined value
        {
            const DiscontinuousUInt16Enum undefined = (DiscontinuousUInt16Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().Be(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<DiscontinuousUInt16Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<DiscontinuousUInt16Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(DiscontinuousUInt16Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<DiscontinuousUInt16Enum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const DiscontinuousUInt16Enum defined = DiscontinuousUInt16Enum.A;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const DiscontinuousUInt16Enum undefined = (DiscontinuousUInt16Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<DiscontinuousUInt16Enum>();
        min.Should().NotBeNull();
        min.Should().Be(DiscontinuousUInt16Enum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<DiscontinuousUInt16Enum>();
        max.Should().NotBeNull();
        max.Should().Be(DiscontinuousUInt16Enum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<DiscontinuousUInt16Enum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<DiscontinuousUInt16Enum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<DiscontinuousUInt16Enum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<DiscontinuousUInt16Enum>(DiscontinuousUInt16Enum.A).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt16Enum>(DiscontinuousUInt16Enum.B).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt16Enum>(DiscontinuousUInt16Enum.C).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt16Enum>((DiscontinuousUInt16Enum)123).Should().BeFalse();

        //--- Extension methods
        DiscontinuousUInt16Enum.A.IsDefined().Should().BeTrue();
        DiscontinuousUInt16Enum.B.IsDefined().Should().BeTrue();
        DiscontinuousUInt16Enum.C.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<DiscontinuousUInt16Enum>(nameof(DiscontinuousUInt16Enum.A)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt16Enum>(nameof(DiscontinuousUInt16Enum.B)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt16Enum>(nameof(DiscontinuousUInt16Enum.C)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt16Enum>("123").Should().BeFalse();
        FastEnum.IsDefined<DiscontinuousUInt16Enum>("value").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousUInt16Enum.A, name: nameof(DiscontinuousUInt16Enum.A), valueString: ((ushort)DiscontinuousUInt16Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt16Enum.B, name: nameof(DiscontinuousUInt16Enum.B), valueString: ((ushort)DiscontinuousUInt16Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt16Enum.C, name: nameof(DiscontinuousUInt16Enum.C), valueString: ((ushort)DiscontinuousUInt16Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousUInt16Enum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<DiscontinuousUInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<DiscontinuousUInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt16Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt16Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt16Enum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt16Enum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt16Enum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousUInt16Enum>("123").Should().Be((DiscontinuousUInt16Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousUInt16Enum.A, name: nameof(DiscontinuousUInt16Enum.A), valueString: ((ushort)DiscontinuousUInt16Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt16Enum.B, name: nameof(DiscontinuousUInt16Enum.B), valueString: ((ushort)DiscontinuousUInt16Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt16Enum.C, name: nameof(DiscontinuousUInt16Enum.C), valueString: ((ushort)DiscontinuousUInt16Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousUInt16Enum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt16Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt16Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt16Enum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt16Enum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt16Enum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousUInt16Enum>("123").Should().Be((DiscontinuousUInt16Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousUInt16Enum.A, name: nameof(DiscontinuousUInt16Enum.A), valueString: ((ushort)DiscontinuousUInt16Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt16Enum.B, name: nameof(DiscontinuousUInt16Enum.B), valueString: ((ushort)DiscontinuousUInt16Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt16Enum.C, name: nameof(DiscontinuousUInt16Enum.C), valueString: ((ushort)DiscontinuousUInt16Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousUInt16Enum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<DiscontinuousUInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeTrue();

            FastEnum.TryParse<DiscontinuousUInt16Enum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousUInt16Enum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt16Enum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt16Enum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt16Enum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt16Enum>("123", out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousUInt16Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousUInt16Enum.A, name: nameof(DiscontinuousUInt16Enum.A), valueString: ((ushort)DiscontinuousUInt16Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt16Enum.B, name: nameof(DiscontinuousUInt16Enum.B), valueString: ((ushort)DiscontinuousUInt16Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt16Enum.C, name: nameof(DiscontinuousUInt16Enum.C), valueString: ((ushort)DiscontinuousUInt16Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousUInt16Enum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt16Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt16Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt16Enum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt16Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt16Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousUInt16Enum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt16Enum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt16Enum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt16Enum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt16Enum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousUInt16Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = DiscontinuousUInt16Enum.A;
        var name = nameof(DiscontinuousUInt16Enum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(DiscontinuousUInt16Enum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        DiscontinuousUInt16Enum.A.ToName().Should().Be(nameof(DiscontinuousUInt16Enum.A));
        DiscontinuousUInt16Enum.B.ToName().Should().Be(nameof(DiscontinuousUInt16Enum.B));
        DiscontinuousUInt16Enum.C.ToName().Should().Be(nameof(DiscontinuousUInt16Enum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = DiscontinuousUInt16Enum.A;
        const ushort value = 1;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        @enum.ToUInt16().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const DiscontinuousUInt16Enum undefined = (DiscontinuousUInt16Enum)123;
        var values = Enum.GetValues<DiscontinuousUInt16Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



[TestClass]
public sealed class DiscontinuousInt32Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<DiscontinuousInt32Enum>().Should().Be<int>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<DiscontinuousInt32Enum>();
        var actual = FastEnum.GetValues<DiscontinuousInt32Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<DiscontinuousInt32Enum>();
        var actual = FastEnum.GetNames<DiscontinuousInt32Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const DiscontinuousInt32Enum defined = DiscontinuousInt32Enum.A;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().Be(expect);
        }
        //--- undefined value
        {
            const DiscontinuousInt32Enum undefined = (DiscontinuousInt32Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().Be(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<DiscontinuousInt32Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<DiscontinuousInt32Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(DiscontinuousInt32Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<DiscontinuousInt32Enum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const DiscontinuousInt32Enum defined = DiscontinuousInt32Enum.A;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const DiscontinuousInt32Enum undefined = (DiscontinuousInt32Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<DiscontinuousInt32Enum>();
        min.Should().NotBeNull();
        min.Should().Be(DiscontinuousInt32Enum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<DiscontinuousInt32Enum>();
        max.Should().NotBeNull();
        max.Should().Be(DiscontinuousInt32Enum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<DiscontinuousInt32Enum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<DiscontinuousInt32Enum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<DiscontinuousInt32Enum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<DiscontinuousInt32Enum>(DiscontinuousInt32Enum.A).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt32Enum>(DiscontinuousInt32Enum.B).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt32Enum>(DiscontinuousInt32Enum.C).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt32Enum>((DiscontinuousInt32Enum)123).Should().BeFalse();

        //--- Extension methods
        DiscontinuousInt32Enum.A.IsDefined().Should().BeTrue();
        DiscontinuousInt32Enum.B.IsDefined().Should().BeTrue();
        DiscontinuousInt32Enum.C.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<DiscontinuousInt32Enum>(nameof(DiscontinuousInt32Enum.A)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt32Enum>(nameof(DiscontinuousInt32Enum.B)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt32Enum>(nameof(DiscontinuousInt32Enum.C)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt32Enum>("123").Should().BeFalse();
        FastEnum.IsDefined<DiscontinuousInt32Enum>("value").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousInt32Enum.A, name: nameof(DiscontinuousInt32Enum.A), valueString: ((int)DiscontinuousInt32Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt32Enum.B, name: nameof(DiscontinuousInt32Enum.B), valueString: ((int)DiscontinuousInt32Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt32Enum.C, name: nameof(DiscontinuousInt32Enum.C), valueString: ((int)DiscontinuousInt32Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousInt32Enum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<DiscontinuousInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<DiscontinuousInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt32Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt32Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt32Enum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt32Enum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt32Enum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousInt32Enum>("123").Should().Be((DiscontinuousInt32Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousInt32Enum.A, name: nameof(DiscontinuousInt32Enum.A), valueString: ((int)DiscontinuousInt32Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt32Enum.B, name: nameof(DiscontinuousInt32Enum.B), valueString: ((int)DiscontinuousInt32Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt32Enum.C, name: nameof(DiscontinuousInt32Enum.C), valueString: ((int)DiscontinuousInt32Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousInt32Enum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt32Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt32Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt32Enum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt32Enum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt32Enum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousInt32Enum>("123").Should().Be((DiscontinuousInt32Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousInt32Enum.A, name: nameof(DiscontinuousInt32Enum.A), valueString: ((int)DiscontinuousInt32Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt32Enum.B, name: nameof(DiscontinuousInt32Enum.B), valueString: ((int)DiscontinuousInt32Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt32Enum.C, name: nameof(DiscontinuousInt32Enum.C), valueString: ((int)DiscontinuousInt32Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousInt32Enum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<DiscontinuousInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeTrue();

            FastEnum.TryParse<DiscontinuousInt32Enum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousInt32Enum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt32Enum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt32Enum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt32Enum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt32Enum>("123", out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousInt32Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousInt32Enum.A, name: nameof(DiscontinuousInt32Enum.A), valueString: ((int)DiscontinuousInt32Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt32Enum.B, name: nameof(DiscontinuousInt32Enum.B), valueString: ((int)DiscontinuousInt32Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt32Enum.C, name: nameof(DiscontinuousInt32Enum.C), valueString: ((int)DiscontinuousInt32Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousInt32Enum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt32Enum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousInt32Enum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt32Enum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt32Enum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt32Enum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt32Enum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousInt32Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = DiscontinuousInt32Enum.A;
        var name = nameof(DiscontinuousInt32Enum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(DiscontinuousInt32Enum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        DiscontinuousInt32Enum.A.ToName().Should().Be(nameof(DiscontinuousInt32Enum.A));
        DiscontinuousInt32Enum.B.ToName().Should().Be(nameof(DiscontinuousInt32Enum.B));
        DiscontinuousInt32Enum.C.ToName().Should().Be(nameof(DiscontinuousInt32Enum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = DiscontinuousInt32Enum.A;
        const int value = 1;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        @enum.ToInt32().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const DiscontinuousInt32Enum undefined = (DiscontinuousInt32Enum)123;
        var values = Enum.GetValues<DiscontinuousInt32Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



[TestClass]
public sealed class DiscontinuousUInt32Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<DiscontinuousUInt32Enum>().Should().Be<uint>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<DiscontinuousUInt32Enum>();
        var actual = FastEnum.GetValues<DiscontinuousUInt32Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<DiscontinuousUInt32Enum>();
        var actual = FastEnum.GetNames<DiscontinuousUInt32Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const DiscontinuousUInt32Enum defined = DiscontinuousUInt32Enum.A;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().Be(expect);
        }
        //--- undefined value
        {
            const DiscontinuousUInt32Enum undefined = (DiscontinuousUInt32Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().Be(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<DiscontinuousUInt32Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<DiscontinuousUInt32Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(DiscontinuousUInt32Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<DiscontinuousUInt32Enum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const DiscontinuousUInt32Enum defined = DiscontinuousUInt32Enum.A;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const DiscontinuousUInt32Enum undefined = (DiscontinuousUInt32Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<DiscontinuousUInt32Enum>();
        min.Should().NotBeNull();
        min.Should().Be(DiscontinuousUInt32Enum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<DiscontinuousUInt32Enum>();
        max.Should().NotBeNull();
        max.Should().Be(DiscontinuousUInt32Enum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<DiscontinuousUInt32Enum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<DiscontinuousUInt32Enum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<DiscontinuousUInt32Enum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<DiscontinuousUInt32Enum>(DiscontinuousUInt32Enum.A).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt32Enum>(DiscontinuousUInt32Enum.B).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt32Enum>(DiscontinuousUInt32Enum.C).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt32Enum>((DiscontinuousUInt32Enum)123).Should().BeFalse();

        //--- Extension methods
        DiscontinuousUInt32Enum.A.IsDefined().Should().BeTrue();
        DiscontinuousUInt32Enum.B.IsDefined().Should().BeTrue();
        DiscontinuousUInt32Enum.C.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<DiscontinuousUInt32Enum>(nameof(DiscontinuousUInt32Enum.A)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt32Enum>(nameof(DiscontinuousUInt32Enum.B)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt32Enum>(nameof(DiscontinuousUInt32Enum.C)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt32Enum>("123").Should().BeFalse();
        FastEnum.IsDefined<DiscontinuousUInt32Enum>("value").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousUInt32Enum.A, name: nameof(DiscontinuousUInt32Enum.A), valueString: ((uint)DiscontinuousUInt32Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt32Enum.B, name: nameof(DiscontinuousUInt32Enum.B), valueString: ((uint)DiscontinuousUInt32Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt32Enum.C, name: nameof(DiscontinuousUInt32Enum.C), valueString: ((uint)DiscontinuousUInt32Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousUInt32Enum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<DiscontinuousUInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<DiscontinuousUInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt32Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt32Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt32Enum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt32Enum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt32Enum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousUInt32Enum>("123").Should().Be((DiscontinuousUInt32Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousUInt32Enum.A, name: nameof(DiscontinuousUInt32Enum.A), valueString: ((uint)DiscontinuousUInt32Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt32Enum.B, name: nameof(DiscontinuousUInt32Enum.B), valueString: ((uint)DiscontinuousUInt32Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt32Enum.C, name: nameof(DiscontinuousUInt32Enum.C), valueString: ((uint)DiscontinuousUInt32Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousUInt32Enum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt32Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt32Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt32Enum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt32Enum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt32Enum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousUInt32Enum>("123").Should().Be((DiscontinuousUInt32Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousUInt32Enum.A, name: nameof(DiscontinuousUInt32Enum.A), valueString: ((uint)DiscontinuousUInt32Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt32Enum.B, name: nameof(DiscontinuousUInt32Enum.B), valueString: ((uint)DiscontinuousUInt32Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt32Enum.C, name: nameof(DiscontinuousUInt32Enum.C), valueString: ((uint)DiscontinuousUInt32Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousUInt32Enum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<DiscontinuousUInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeTrue();

            FastEnum.TryParse<DiscontinuousUInt32Enum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousUInt32Enum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt32Enum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt32Enum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt32Enum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt32Enum>("123", out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousUInt32Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousUInt32Enum.A, name: nameof(DiscontinuousUInt32Enum.A), valueString: ((uint)DiscontinuousUInt32Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt32Enum.B, name: nameof(DiscontinuousUInt32Enum.B), valueString: ((uint)DiscontinuousUInt32Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt32Enum.C, name: nameof(DiscontinuousUInt32Enum.C), valueString: ((uint)DiscontinuousUInt32Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousUInt32Enum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt32Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt32Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt32Enum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt32Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt32Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousUInt32Enum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt32Enum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt32Enum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt32Enum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt32Enum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousUInt32Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = DiscontinuousUInt32Enum.A;
        var name = nameof(DiscontinuousUInt32Enum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(DiscontinuousUInt32Enum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        DiscontinuousUInt32Enum.A.ToName().Should().Be(nameof(DiscontinuousUInt32Enum.A));
        DiscontinuousUInt32Enum.B.ToName().Should().Be(nameof(DiscontinuousUInt32Enum.B));
        DiscontinuousUInt32Enum.C.ToName().Should().Be(nameof(DiscontinuousUInt32Enum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = DiscontinuousUInt32Enum.A;
        const uint value = 1;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        @enum.ToUInt32().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const DiscontinuousUInt32Enum undefined = (DiscontinuousUInt32Enum)123;
        var values = Enum.GetValues<DiscontinuousUInt32Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



[TestClass]
public sealed class DiscontinuousInt64Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<DiscontinuousInt64Enum>().Should().Be<long>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<DiscontinuousInt64Enum>();
        var actual = FastEnum.GetValues<DiscontinuousInt64Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<DiscontinuousInt64Enum>();
        var actual = FastEnum.GetNames<DiscontinuousInt64Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const DiscontinuousInt64Enum defined = DiscontinuousInt64Enum.A;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().Be(expect);
        }
        //--- undefined value
        {
            const DiscontinuousInt64Enum undefined = (DiscontinuousInt64Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().Be(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<DiscontinuousInt64Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<DiscontinuousInt64Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(DiscontinuousInt64Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<DiscontinuousInt64Enum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const DiscontinuousInt64Enum defined = DiscontinuousInt64Enum.A;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const DiscontinuousInt64Enum undefined = (DiscontinuousInt64Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<DiscontinuousInt64Enum>();
        min.Should().NotBeNull();
        min.Should().Be(DiscontinuousInt64Enum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<DiscontinuousInt64Enum>();
        max.Should().NotBeNull();
        max.Should().Be(DiscontinuousInt64Enum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<DiscontinuousInt64Enum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<DiscontinuousInt64Enum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<DiscontinuousInt64Enum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<DiscontinuousInt64Enum>(DiscontinuousInt64Enum.A).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt64Enum>(DiscontinuousInt64Enum.B).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt64Enum>(DiscontinuousInt64Enum.C).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt64Enum>((DiscontinuousInt64Enum)123).Should().BeFalse();

        //--- Extension methods
        DiscontinuousInt64Enum.A.IsDefined().Should().BeTrue();
        DiscontinuousInt64Enum.B.IsDefined().Should().BeTrue();
        DiscontinuousInt64Enum.C.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<DiscontinuousInt64Enum>(nameof(DiscontinuousInt64Enum.A)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt64Enum>(nameof(DiscontinuousInt64Enum.B)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt64Enum>(nameof(DiscontinuousInt64Enum.C)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousInt64Enum>("123").Should().BeFalse();
        FastEnum.IsDefined<DiscontinuousInt64Enum>("value").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousInt64Enum.A, name: nameof(DiscontinuousInt64Enum.A), valueString: ((long)DiscontinuousInt64Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt64Enum.B, name: nameof(DiscontinuousInt64Enum.B), valueString: ((long)DiscontinuousInt64Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt64Enum.C, name: nameof(DiscontinuousInt64Enum.C), valueString: ((long)DiscontinuousInt64Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousInt64Enum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<DiscontinuousInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<DiscontinuousInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt64Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt64Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt64Enum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt64Enum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt64Enum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousInt64Enum>("123").Should().Be((DiscontinuousInt64Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousInt64Enum.A, name: nameof(DiscontinuousInt64Enum.A), valueString: ((long)DiscontinuousInt64Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt64Enum.B, name: nameof(DiscontinuousInt64Enum.B), valueString: ((long)DiscontinuousInt64Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt64Enum.C, name: nameof(DiscontinuousInt64Enum.C), valueString: ((long)DiscontinuousInt64Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousInt64Enum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt64Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousInt64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt64Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt64Enum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt64Enum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousInt64Enum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousInt64Enum>("123").Should().Be((DiscontinuousInt64Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousInt64Enum.A, name: nameof(DiscontinuousInt64Enum.A), valueString: ((long)DiscontinuousInt64Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt64Enum.B, name: nameof(DiscontinuousInt64Enum.B), valueString: ((long)DiscontinuousInt64Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt64Enum.C, name: nameof(DiscontinuousInt64Enum.C), valueString: ((long)DiscontinuousInt64Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousInt64Enum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<DiscontinuousInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeTrue();

            FastEnum.TryParse<DiscontinuousInt64Enum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousInt64Enum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt64Enum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt64Enum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt64Enum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt64Enum>("123", out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousInt64Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousInt64Enum.A, name: nameof(DiscontinuousInt64Enum.A), valueString: ((long)DiscontinuousInt64Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt64Enum.B, name: nameof(DiscontinuousInt64Enum.B), valueString: ((long)DiscontinuousInt64Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousInt64Enum.C, name: nameof(DiscontinuousInt64Enum.C), valueString: ((long)DiscontinuousInt64Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousInt64Enum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt64Enum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousInt64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousInt64Enum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt64Enum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt64Enum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt64Enum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousInt64Enum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousInt64Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = DiscontinuousInt64Enum.A;
        var name = nameof(DiscontinuousInt64Enum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(DiscontinuousInt64Enum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        DiscontinuousInt64Enum.A.ToName().Should().Be(nameof(DiscontinuousInt64Enum.A));
        DiscontinuousInt64Enum.B.ToName().Should().Be(nameof(DiscontinuousInt64Enum.B));
        DiscontinuousInt64Enum.C.ToName().Should().Be(nameof(DiscontinuousInt64Enum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = DiscontinuousInt64Enum.A;
        const long value = 1;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        @enum.ToInt64().Should().Be(value);
        FluentActions.Invoking(() => @enum.ToUInt64()).Should().Throw<ArgumentException>();
    }


    [TestMethod]
    public void FastToString()
    {
        const DiscontinuousInt64Enum undefined = (DiscontinuousInt64Enum)123;
        var values = Enum.GetValues<DiscontinuousInt64Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



[TestClass]
public sealed class DiscontinuousUInt64Tests
{
    [TestMethod]
    public void GetUnderlyingType()
        => FastEnum.GetUnderlyingType<DiscontinuousUInt64Enum>().Should().Be<ulong>();


    [TestMethod]
    public void GetValues()
    {
        var expect = Enum.GetValues<DiscontinuousUInt64Enum>();
        var actual = FastEnum.GetValues<DiscontinuousUInt64Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetNames()
    {
        var expect = Enum.GetNames<DiscontinuousUInt64Enum>();
        var actual = FastEnum.GetNames<DiscontinuousUInt64Enum>();
        actual.Should().BeEquivalentTo(expect);
    }


    [TestMethod]
    public void GetName()
    {
        //--- defined value
        {
            const DiscontinuousUInt64Enum defined = DiscontinuousUInt64Enum.A;
            var expect = Enum.GetName(defined);
            var actual = FastEnum.GetName(defined);
            actual.Should().NotBeNull();
            actual.Should().Be(expect);
        }
        //--- undefined value
        {
            const DiscontinuousUInt64Enum undefined = (DiscontinuousUInt64Enum)123;
            var expect = Enum.GetName(undefined);
            var actual = FastEnum.GetName(undefined);
            actual.Should().BeNull();
            actual.Should().Be(expect);
        }
    }


    [TestMethod]
    public void GetMembers()
    {
        var expect
            = Enum.GetNames<DiscontinuousUInt64Enum>()
            .Select(static name =>
            {
                var value = Enum.Parse<DiscontinuousUInt64Enum>(name);
                var nameUtf8 = Encoding.UTF8.GetBytes(name);
                var fieldInfo = typeof(DiscontinuousUInt64Enum).GetField(name);
                return (value, name, nameUtf8, fieldInfo);
            })
            .ToArray();
        var actual = FastEnum.GetMembers<DiscontinuousUInt64Enum>();

        actual.Length.Should().Be(expect.Length);
        for (var i = 0; i < expect.Length; i++)
        {
            var a = actual[i];
            var e = expect[i];
            a.Value.Should().Be(e.value);
            a.Name.Should().Be(e.name);
            a.NameUtf8.Should().Equal(e.nameUtf8);
            a.FieldInfo.Should().Be(e.fieldInfo);

            var (name, value) = a;
            value.Should().Be(e.value);
            name.Should().Be(e.name);
        }
    }


    [TestMethod]
    public void GetMember()
    {
        //--- defined value
        {
            const DiscontinuousUInt64Enum defined = DiscontinuousUInt64Enum.A;
            var expect = getMember(defined);
            var actual = FastEnum.GetMember(defined)!;

            actual.Should().NotBeNull();
            actual.Value.Should().Be(expect.value);
            actual.Name.Should().Be(expect.name);
            actual.NameUtf8.Should().Equal(expect.nameUtf8);
            actual.FieldInfo.Should().Be(expect.fieldInfo);

            var (name, value) = actual;
            value.Should().Be(expect.value);
            name.Should().Be(expect.name);
        }
        //--- undefined value
        {
            const DiscontinuousUInt64Enum undefined = (DiscontinuousUInt64Enum)123;
            var actual = FastEnum.GetMember(undefined);
            actual.Should().BeNull();
        }

        #region Local Functions
        static (T value, string name, byte[] nameUtf8, FieldInfo fieldInfo) getMember<T>(T value)
            where T : struct, Enum
        {
            var name = Enum.GetName<T>(value)!;
            var nameUtf8 = Encoding.UTF8.GetBytes(name);
            var fieldInfo = typeof(T).GetField(name)!;
            return (value, name, nameUtf8, fieldInfo);
        }
        #endregion
    }


    [TestMethod]
    public void GetMinValue()
    {
        var min = FastEnum.GetMinValue<DiscontinuousUInt64Enum>();
        min.Should().NotBeNull();
        min.Should().Be(DiscontinuousUInt64Enum.A);
    }


    [TestMethod]
    public void GetMaxValue()
    {
        var max = FastEnum.GetMaxValue<DiscontinuousUInt64Enum>();
        max.Should().NotBeNull();
        max.Should().Be(DiscontinuousUInt64Enum.C);
    }


    [TestMethod]
    public void IsEmpty()
        => FastEnum.IsEmpty<DiscontinuousUInt64Enum>().Should().Be(false);


    [TestMethod]
    public void IsContinuous()
        => FastEnum.IsContinuous<DiscontinuousUInt64Enum>().Should().Be(false);


    [TestMethod]
    public void IsFlags()
        => FastEnum.IsFlags<DiscontinuousUInt64Enum>().Should().Be(false);


    [TestMethod]
    public void IsDefined()
    {
        //--- IsDefined(TEnum)
        FastEnum.IsDefined<DiscontinuousUInt64Enum>(DiscontinuousUInt64Enum.A).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt64Enum>(DiscontinuousUInt64Enum.B).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt64Enum>(DiscontinuousUInt64Enum.C).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt64Enum>((DiscontinuousUInt64Enum)123).Should().BeFalse();

        //--- Extension methods
        DiscontinuousUInt64Enum.A.IsDefined().Should().BeTrue();
        DiscontinuousUInt64Enum.B.IsDefined().Should().BeTrue();
        DiscontinuousUInt64Enum.C.IsDefined().Should().BeTrue();

        //--- IsDefined(ReadOnlySpan<char>)
        FastEnum.IsDefined<DiscontinuousUInt64Enum>(nameof(DiscontinuousUInt64Enum.A)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt64Enum>(nameof(DiscontinuousUInt64Enum.B)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt64Enum>(nameof(DiscontinuousUInt64Enum.C)).Should().BeTrue();
        FastEnum.IsDefined<DiscontinuousUInt64Enum>("123").Should().BeFalse();
        FastEnum.IsDefined<DiscontinuousUInt64Enum>("value").Should().BeFalse();
    }


    [TestMethod]
    public void Parse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousUInt64Enum.A, name: nameof(DiscontinuousUInt64Enum.A), valueString: ((ulong)DiscontinuousUInt64Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt64Enum.B, name: nameof(DiscontinuousUInt64Enum.B), valueString: ((ulong)DiscontinuousUInt64Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt64Enum.C, name: nameof(DiscontinuousUInt64Enum.C), valueString: ((ulong)DiscontinuousUInt64Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousUInt64Enum>(x.name).Should().Be(x.value);
            FluentActions.Invoking(() => FastEnum.Parse<DiscontinuousUInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture))).Should().Throw<ArgumentException>();
            FastEnum.Parse<DiscontinuousUInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt64Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture)).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture)).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt64Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt64Enum>("")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt64Enum>(" ")).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt64Enum>("ABCDE")).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousUInt64Enum>("123").Should().Be((DiscontinuousUInt64Enum)123);
    }


    [TestMethod]
    public void ParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousUInt64Enum.A, name: nameof(DiscontinuousUInt64Enum.A), valueString: ((ulong)DiscontinuousUInt64Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt64Enum.B, name: nameof(DiscontinuousUInt64Enum.B), valueString: ((ulong)DiscontinuousUInt64Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt64Enum.C, name: nameof(DiscontinuousUInt64Enum.C), valueString: ((ulong)DiscontinuousUInt64Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.Parse<DiscontinuousUInt64Enum>(x.name, true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt64Enum>(x.valueString).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true).Should().Be(x.value);
            FastEnum.Parse<DiscontinuousUInt64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true).Should().Be(x.value);
        }
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt64Enum>((string?)null, true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt64Enum>("", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt64Enum>(" ", true)).Should().Throw<ArgumentException>();
        FluentActions.Invoking(static () => FastEnum.Parse<DiscontinuousUInt64Enum>("ABCDE", true)).Should().Throw<ArgumentException>();
        FastEnum.Parse<DiscontinuousUInt64Enum>("123").Should().Be((DiscontinuousUInt64Enum)123);
    }


    [TestMethod]
    public void TryParse()
    {
        var parameters = new[]
        {
            (value: DiscontinuousUInt64Enum.A, name: nameof(DiscontinuousUInt64Enum.A), valueString: ((ulong)DiscontinuousUInt64Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt64Enum.B, name: nameof(DiscontinuousUInt64Enum.B), valueString: ((ulong)DiscontinuousUInt64Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt64Enum.C, name: nameof(DiscontinuousUInt64Enum.C), valueString: ((ulong)DiscontinuousUInt64Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousUInt64Enum>(x.name, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), out var _).Should().BeFalse();
            FastEnum.TryParse<DiscontinuousUInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), out var _).Should().BeTrue();

            FastEnum.TryParse<DiscontinuousUInt64Enum>(x.valueString, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), out var r4).Should().BeTrue();
            r4.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousUInt64Enum>((string?)null, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt64Enum>("", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt64Enum>(" ", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt64Enum>("ABCDE", out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt64Enum>("123", out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousUInt64Enum)123);
    }


    [TestMethod]
    public void TryParseIgnoreCase()
    {
        var parameters = new[]
        {
            (value: DiscontinuousUInt64Enum.A, name: nameof(DiscontinuousUInt64Enum.A), valueString: ((ulong)DiscontinuousUInt64Enum.A).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt64Enum.B, name: nameof(DiscontinuousUInt64Enum.B), valueString: ((ulong)DiscontinuousUInt64Enum.B).ToString(CultureInfo.InvariantCulture)),
            (value: DiscontinuousUInt64Enum.C, name: nameof(DiscontinuousUInt64Enum.C), valueString: ((ulong)DiscontinuousUInt64Enum.C).ToString(CultureInfo.InvariantCulture)),
        };
        foreach (var x in parameters)
        {
            FastEnum.TryParse<DiscontinuousUInt64Enum>(x.name, true, out var r1).Should().BeTrue();
            r1.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt64Enum>(x.name.ToLower(CultureInfo.InvariantCulture), true, out var r2).Should().BeTrue();
            r2.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt64Enum>(x.name.ToUpper(CultureInfo.InvariantCulture), true, out var r3).Should().BeTrue();
            r3.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt64Enum>(x.valueString, true, out var r4).Should().BeTrue();
            r4.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt64Enum>(x.valueString.ToLower(CultureInfo.InvariantCulture), true, out var r5).Should().BeTrue();
            r5.Should().Be(x.value);

            FastEnum.TryParse<DiscontinuousUInt64Enum>(x.valueString.ToUpper(CultureInfo.InvariantCulture), true, out var r6).Should().BeTrue();
            r6.Should().Be(x.value);
        }
        FastEnum.TryParse<DiscontinuousUInt64Enum>((string?)null, true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt64Enum>("", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt64Enum>(" ", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt64Enum>("ABCDE", true, out var _).Should().BeFalse();
        FastEnum.TryParse<DiscontinuousUInt64Enum>("123", true, out var r).Should().BeTrue();
        r.Should().Be((DiscontinuousUInt64Enum)123);
    }


    [TestMethod]
    public void ToMember()
    {
        var value = DiscontinuousUInt64Enum.A;
        var name = nameof(DiscontinuousUInt64Enum.A);
        var nameUtf8 = Encoding.UTF8.GetBytes(name);
        var member = value.ToMember()!;
        var info = typeof(DiscontinuousUInt64Enum).GetField(name);

        member.Should().NotBeNull();
        member.Name.Should().Be(name);
        member.NameUtf8.Should().Equal(nameUtf8);
        member.Value.Should().Be(value);
        member.FieldInfo.Should().Be(info);
    }


    [TestMethod]
    public void ToName()
    {
        DiscontinuousUInt64Enum.A.ToName().Should().Be(nameof(DiscontinuousUInt64Enum.A));
        DiscontinuousUInt64Enum.B.ToName().Should().Be(nameof(DiscontinuousUInt64Enum.B));
        DiscontinuousUInt64Enum.C.ToName().Should().Be(nameof(DiscontinuousUInt64Enum.C));
    }


    [TestMethod]
    public void ToUnderlying()
    {
        var @enum = DiscontinuousUInt64Enum.A;
        const ulong value = 1;

        FluentActions.Invoking(() => @enum.ToSByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToByte()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt16()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToUInt32()).Should().Throw<ArgumentException>();
        FluentActions.Invoking(() => @enum.ToInt64()).Should().Throw<ArgumentException>();
        @enum.ToUInt64().Should().Be(value);
    }


    [TestMethod]
    public void FastToString()
    {
        const DiscontinuousUInt64Enum undefined = (DiscontinuousUInt64Enum)123;
        var values = Enum.GetValues<DiscontinuousUInt64Enum>().Append(undefined);
        foreach (var x in values)
        {
            var expect = x.ToString();
            var actual = x.FastToString();
            actual.Should().Be(expect);
        }
    }
}



