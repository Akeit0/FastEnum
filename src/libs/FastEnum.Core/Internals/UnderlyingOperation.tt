<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var parameters = new[]
    {
        new { TypeName = "SByte",  CompatibleName = "sbyte",  },
        new { TypeName = "Byte",   CompatibleName = "byte",   },
        new { TypeName = "Int16",  CompatibleName = "short",  },
        new { TypeName = "UInt16", CompatibleName = "ushort", },
        new { TypeName = "Int32",  CompatibleName = "int",    },
        new { TypeName = "UInt32", CompatibleName = "uint",   },
        new { TypeName = "Int64",  CompatibleName = "long",   },
        new { TypeName = "UInt64", CompatibleName = "ulong",  },
    };
#>
// <auto-generated>
// This .cs file is generated by T4 template. Don't change it. Change the .tt file instead.
// </auto-generated>
#nullable enable

using System;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace FastEnumUtility.Internals;



internal static class UnderlyingOperation
{
    public static IFastEnumOperation<T> Create<T>()
        where T : struct, Enum
    {
        return EnumInfo<T>.s_typeCode switch
        {
<# foreach (var x in parameters) { #>
            TypeCode.<#= x.TypeName #> => <#= x.TypeName #>Operation<T>.Create(),
<# } #>
            _ => throw new InvalidOperationException(),
        };
    }
}



<# foreach (var x in parameters) { #>
file static class <#= x.TypeName #>Operation<T>
    where T : struct, Enum
{
    #region Factories
    public static IFastEnumOperation<T> Create()
        => EnumInfo<T>.s_isContinuous
        ? new Continuous()
        : new Discontinuous();
    #endregion


    #region Nested Types
    private sealed class Continuous : IFastEnumOperation<T>
    {
        #region Fields
        private readonly <#= x.CompatibleName #> _minValue;
        private readonly <#= x.CompatibleName #> _maxValue;
        #endregion


        #region Constructors
        public Continuous()
        {
            var min = EnumInfo<T>.s_minValue;
            var max = EnumInfo<T>.s_maxValue;
            this._minValue = Unsafe.As<T, <#= x.CompatibleName #>>(ref min);
            this._maxValue = Unsafe.As<T, <#= x.CompatibleName #>>(ref max);
        }
        #endregion


        #region IFastEnumOperation<T>
        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsDefined(T value)
        {
            ref var val = ref Unsafe.As<T, <#= x.CompatibleName #>>(ref value);
            return (this._minValue <= val) && (val <= this._maxValue);
        }


        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string ToString(T value)
        {
            var self = (IFastEnumOperation<T>)this;
            if (self.TryGetMember(value, out var member))
            {
                return member.Name;
            }
            else
            {
                ref var x = ref Unsafe.As<T, <#= x.CompatibleName #>>(ref value);
                return x.ToString(null, CultureInfo.InvariantCulture);
            }
        }


        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMember(T value, [NotNullWhen(true)] out Member<T>? result)
        {
            var members = EnumInfo<T>.s_orderedMembers;
            ref var val = ref Unsafe.As<T, <#= x.CompatibleName #>>(ref value);
            var index = val - this._minValue;
            if ((uint)index < (uint)members.Length)
            {
                result = members[index];
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }


        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryParseValue(string text, out T result)
        {
            Unsafe.SkipInit(out result);
            ref var x = ref Unsafe.As<T, <#= x.CompatibleName #>>(ref result);
            return <#= x.CompatibleName #>.TryParse(text, CultureInfo.InvariantCulture, out x);
        }
        #endregion
    }



    private sealed class Discontinuous : IFastEnumOperation<T>
    {
        #region IFastEnumOperation<T>
        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string ToString(T value)
        {
            var self = (IFastEnumOperation<T>)this;
            if (self.TryGetMember(value, out var member))
            {
                return member.Name;
            }
            else
            {
                ref var x = ref Unsafe.As<T, <#= x.CompatibleName #>>(ref value);
                return x.ToString(null, CultureInfo.InvariantCulture);
            }
        }


        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryParseValue(string text, out T result)
        {
            Unsafe.SkipInit(out result);
            ref var x = ref Unsafe.As<T, <#= x.CompatibleName #>>(ref result);
            return <#= x.CompatibleName #>.TryParse(text, CultureInfo.InvariantCulture, out x);
        }
        #endregion
    }
    #endregion
}



<# } #>