using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FastEnumUtility.Generators.Emitters;



internal static class ClassDeclarationEmitter
{
    public static void Register(IncrementalGeneratorInitializationContext context)
    {
        var typeDeclarations
            = context.SyntaxProvider.ForAttributeWithMetadataName
            (
                fullyQualifiedMetadataName: "FastEnumUtility.FastEnumAttribute`1",
                predicate: static (node, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return node is ClassDeclarationSyntax;
                },
                transform: static (context, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return context;
                }
            );
        var parseOptions = context.ParseOptionsProvider;
        var source = typeDeclarations.Combine(parseOptions);

        context.RegisterSourceOutput(source, static (context, source) =>
        {
            var syntax = source.Left;
            var options = (CSharpParseOptions)source.Right;
            var param = new GenerateParameters(syntax, options);
            var code = Generate(param);
            context.AddSource(param.FileName, code);
        });
    }


    private static string Generate(GenerateParameters param)
    {
        var sb = new StringBuilder();

        //--- header
        sb.AppendLine("""
            // <auto-generated>
            // This .cs file is generated by FastEnum source generator.
            // </auto-generated>
            #nullable enable

            using System;
            using System.Globalization;
            using System.Runtime.CompilerServices;
            using FastEnumUtility;
            """);

        //--- ok
        return sb.ToString();
    }


    #region Nested Types
    private sealed class GenerateParameters
    {
        #region Properties
        public LanguageVersion LanguageVersion { get; }
        public bool IsGlobalNamespace { get; }
        public string Namespace { get; }
        public string Modifier { get; }
        public string ClassName { get; }
        public string EnumType { get; }
        public string UnderlyingType { get; }
        public IReadOnlyList<IFieldSymbol> Fields { get; }
        public string FileName { get; }
        #endregion


        #region Constructors
        public GenerateParameters(GeneratorAttributeSyntaxContext context, CSharpParseOptions parseOptions)
        {
            var symbol = (INamedTypeSymbol)context.TargetSymbol;
            var attr = context.Attributes.First(static x => x.AttributeClass!.MetadataName is "FastEnumAttribute`1");
            var enumType = (INamedTypeSymbol)attr.AttributeClass!.TypeArguments[0];

            this.LanguageVersion = parseOptions.LanguageVersion;
            this.IsGlobalNamespace = symbol.ContainingNamespace.IsGlobalNamespace;
            this.Namespace = symbol.ContainingNamespace.ToDisplayString();
            this.Modifier = "partial";
            this.ClassName = symbol.ToDisplayString();
            this.EnumType = enumType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            this.UnderlyingType = enumType.EnumUnderlyingType?.ToDisplayString() ?? "int";
            this.Fields = enumType.GetMembers().OfType<IFieldSymbol>().ToArray();

            var className = this.ClassName.Replace("<", "_").Replace(">", "_");
            this.FileName = $"{className}.FastEnumBooster.g.cs";
        }
        #endregion
    }
    #endregion
}
