// <auto-generated>
// This .cs file is generated by T4 template. Don't change it. Change the .tt file instead.
// </auto-generated>
using System;
using System.Runtime.CompilerServices;

namespace FastEnumUtility.Internals;



/// <summary>
/// Provides underlying type specified operation interface.
/// </summary>
/// <typeparam name="T">Enum type</typeparam>
internal interface IUnderlyingOperation<T>
    where T : struct, Enum
{
    bool IsContinuous { get; }
    bool IsDefined(ref T value);
    bool TryParse(string text, out T result);
    bool TryGetMember(ref T value, out Member<T> result);
}



/// <summary>
/// Provides sbyte specified operation.
/// </summary>
/// <typeparam name="T">Enum type</typeparam>
internal static class SByteOperation<T>
    where T : struct, Enum
{
    #region Inner Classes
    private abstract class UnderlyingOperation : IUnderlyingOperation<T>
    {
        public abstract bool IsContinuous { get; }
        public abstract bool IsDefined(ref T value);
        public abstract bool IsDefined(ref sbyte value);
        public abstract bool TryGetMember(ref T value, out Member<T> result);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryParse(string text, out T result)
        {
            result = default;
            ref var x = ref Unsafe.As<T, sbyte>(ref result);
            return sbyte.TryParse(text, out x);
        }
    }


    private sealed class Continuous : UnderlyingOperation
    {
        private readonly sbyte _minValue;
        private readonly sbyte _maxValue;
        private readonly Member<T>[] _members;

        public Continuous(sbyte min, sbyte max, Member<T>[] members)
        {
            this._minValue = min;
            this._maxValue = max;
            this._members = members;
        }

        public override bool IsContinuous
            => true;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, sbyte>(ref value);
            return (this._minValue <= val) && (val <= this._maxValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref sbyte value)
            => (this._minValue <= value) && (value <= this._maxValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, sbyte>(ref value);
            var index = val - this._minValue;
            if (0 <= index && index < this._members.Length)
            {
                result = this._members[index];
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }
    }


    private sealed class Discontinuous : UnderlyingOperation
    {
        private readonly FrozenSByteKeyDictionary<Member<T>> _memberByValue;

        public Discontinuous(FrozenSByteKeyDictionary<Member<T>> memberByValue)
            => this._memberByValue = memberByValue;

        public override bool IsContinuous
            => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, sbyte>(ref value);
            return this._memberByValue.ContainsKey(val);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref sbyte value)
            => this._memberByValue.ContainsKey(value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, sbyte>(ref value);
            return this._memberByValue.TryGetValue(val, out result);
        }
    }
    #endregion


    #region Fields
    private static UnderlyingOperation _operation;
    #endregion


    #region Create
    public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
    {
        var minValue = Unsafe.As<T, sbyte>(ref min);
        var maxValue = Unsafe.As<T, sbyte>(ref max);
        var memberByValue
            = members.ToFrozenSByteKeyDictionary(static x =>
            {
                var value = x.Value;
                return Unsafe.As<T, sbyte>(ref value);
            });
        if (memberByValue.Count > 0)
        {
            var length = maxValue - minValue;
            var count = memberByValue.Count - 1;
            if (length == count)
            {
                _operation = new Continuous(minValue, maxValue, members);
                return _operation;
            }
        }
        _operation = new Discontinuous(memberByValue);
        return _operation;
    }
    #endregion


    #region IsDefined
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsDefined(ref sbyte value)
        => _operation.IsDefined(ref value);
    #endregion
}



/// <summary>
/// Provides byte specified operation.
/// </summary>
/// <typeparam name="T">Enum type</typeparam>
internal static class ByteOperation<T>
    where T : struct, Enum
{
    #region Inner Classes
    private abstract class UnderlyingOperation : IUnderlyingOperation<T>
    {
        public abstract bool IsContinuous { get; }
        public abstract bool IsDefined(ref T value);
        public abstract bool IsDefined(ref byte value);
        public abstract bool TryGetMember(ref T value, out Member<T> result);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryParse(string text, out T result)
        {
            result = default;
            ref var x = ref Unsafe.As<T, byte>(ref result);
            return byte.TryParse(text, out x);
        }
    }


    private sealed class Continuous : UnderlyingOperation
    {
        private readonly byte _minValue;
        private readonly byte _maxValue;
        private readonly Member<T>[] _members;

        public Continuous(byte min, byte max, Member<T>[] members)
        {
            this._minValue = min;
            this._maxValue = max;
            this._members = members;
        }

        public override bool IsContinuous
            => true;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, byte>(ref value);
            return (this._minValue <= val) && (val <= this._maxValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref byte value)
            => (this._minValue <= value) && (value <= this._maxValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, byte>(ref value);
            var index = val - this._minValue;
            if (0 <= index && index < this._members.Length)
            {
                result = this._members[index];
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }
    }


    private sealed class Discontinuous : UnderlyingOperation
    {
        private readonly FrozenByteKeyDictionary<Member<T>> _memberByValue;

        public Discontinuous(FrozenByteKeyDictionary<Member<T>> memberByValue)
            => this._memberByValue = memberByValue;

        public override bool IsContinuous
            => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, byte>(ref value);
            return this._memberByValue.ContainsKey(val);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref byte value)
            => this._memberByValue.ContainsKey(value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, byte>(ref value);
            return this._memberByValue.TryGetValue(val, out result);
        }
    }
    #endregion


    #region Fields
    private static UnderlyingOperation _operation;
    #endregion


    #region Create
    public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
    {
        var minValue = Unsafe.As<T, byte>(ref min);
        var maxValue = Unsafe.As<T, byte>(ref max);
        var memberByValue
            = members.ToFrozenByteKeyDictionary(static x =>
            {
                var value = x.Value;
                return Unsafe.As<T, byte>(ref value);
            });
        if (memberByValue.Count > 0)
        {
            var length = maxValue - minValue;
            var count = memberByValue.Count - 1;
            if (length == count)
            {
                _operation = new Continuous(minValue, maxValue, members);
                return _operation;
            }
        }
        _operation = new Discontinuous(memberByValue);
        return _operation;
    }
    #endregion


    #region IsDefined
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsDefined(ref byte value)
        => _operation.IsDefined(ref value);
    #endregion
}



/// <summary>
/// Provides short specified operation.
/// </summary>
/// <typeparam name="T">Enum type</typeparam>
internal static class Int16Operation<T>
    where T : struct, Enum
{
    #region Inner Classes
    private abstract class UnderlyingOperation : IUnderlyingOperation<T>
    {
        public abstract bool IsContinuous { get; }
        public abstract bool IsDefined(ref T value);
        public abstract bool IsDefined(ref short value);
        public abstract bool TryGetMember(ref T value, out Member<T> result);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryParse(string text, out T result)
        {
            result = default;
            ref var x = ref Unsafe.As<T, short>(ref result);
            return short.TryParse(text, out x);
        }
    }


    private sealed class Continuous : UnderlyingOperation
    {
        private readonly short _minValue;
        private readonly short _maxValue;
        private readonly Member<T>[] _members;

        public Continuous(short min, short max, Member<T>[] members)
        {
            this._minValue = min;
            this._maxValue = max;
            this._members = members;
        }

        public override bool IsContinuous
            => true;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, short>(ref value);
            return (this._minValue <= val) && (val <= this._maxValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref short value)
            => (this._minValue <= value) && (value <= this._maxValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, short>(ref value);
            var index = val - this._minValue;
            if (0 <= index && index < this._members.Length)
            {
                result = this._members[index];
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }
    }


    private sealed class Discontinuous : UnderlyingOperation
    {
        private readonly FrozenInt16KeyDictionary<Member<T>> _memberByValue;

        public Discontinuous(FrozenInt16KeyDictionary<Member<T>> memberByValue)
            => this._memberByValue = memberByValue;

        public override bool IsContinuous
            => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, short>(ref value);
            return this._memberByValue.ContainsKey(val);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref short value)
            => this._memberByValue.ContainsKey(value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, short>(ref value);
            return this._memberByValue.TryGetValue(val, out result);
        }
    }
    #endregion


    #region Fields
    private static UnderlyingOperation _operation;
    #endregion


    #region Create
    public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
    {
        var minValue = Unsafe.As<T, short>(ref min);
        var maxValue = Unsafe.As<T, short>(ref max);
        var memberByValue
            = members.ToFrozenInt16KeyDictionary(static x =>
            {
                var value = x.Value;
                return Unsafe.As<T, short>(ref value);
            });
        if (memberByValue.Count > 0)
        {
            var length = maxValue - minValue;
            var count = memberByValue.Count - 1;
            if (length == count)
            {
                _operation = new Continuous(minValue, maxValue, members);
                return _operation;
            }
        }
        _operation = new Discontinuous(memberByValue);
        return _operation;
    }
    #endregion


    #region IsDefined
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsDefined(ref short value)
        => _operation.IsDefined(ref value);
    #endregion
}



/// <summary>
/// Provides ushort specified operation.
/// </summary>
/// <typeparam name="T">Enum type</typeparam>
internal static class UInt16Operation<T>
    where T : struct, Enum
{
    #region Inner Classes
    private abstract class UnderlyingOperation : IUnderlyingOperation<T>
    {
        public abstract bool IsContinuous { get; }
        public abstract bool IsDefined(ref T value);
        public abstract bool IsDefined(ref ushort value);
        public abstract bool TryGetMember(ref T value, out Member<T> result);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryParse(string text, out T result)
        {
            result = default;
            ref var x = ref Unsafe.As<T, ushort>(ref result);
            return ushort.TryParse(text, out x);
        }
    }


    private sealed class Continuous : UnderlyingOperation
    {
        private readonly ushort _minValue;
        private readonly ushort _maxValue;
        private readonly Member<T>[] _members;

        public Continuous(ushort min, ushort max, Member<T>[] members)
        {
            this._minValue = min;
            this._maxValue = max;
            this._members = members;
        }

        public override bool IsContinuous
            => true;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, ushort>(ref value);
            return (this._minValue <= val) && (val <= this._maxValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref ushort value)
            => (this._minValue <= value) && (value <= this._maxValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, ushort>(ref value);
            var index = val - this._minValue;
            if (0 <= index && index < this._members.Length)
            {
                result = this._members[index];
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }
    }


    private sealed class Discontinuous : UnderlyingOperation
    {
        private readonly FrozenUInt16KeyDictionary<Member<T>> _memberByValue;

        public Discontinuous(FrozenUInt16KeyDictionary<Member<T>> memberByValue)
            => this._memberByValue = memberByValue;

        public override bool IsContinuous
            => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, ushort>(ref value);
            return this._memberByValue.ContainsKey(val);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref ushort value)
            => this._memberByValue.ContainsKey(value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, ushort>(ref value);
            return this._memberByValue.TryGetValue(val, out result);
        }
    }
    #endregion


    #region Fields
    private static UnderlyingOperation _operation;
    #endregion


    #region Create
    public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
    {
        var minValue = Unsafe.As<T, ushort>(ref min);
        var maxValue = Unsafe.As<T, ushort>(ref max);
        var memberByValue
            = members.ToFrozenUInt16KeyDictionary(static x =>
            {
                var value = x.Value;
                return Unsafe.As<T, ushort>(ref value);
            });
        if (memberByValue.Count > 0)
        {
            var length = maxValue - minValue;
            var count = memberByValue.Count - 1;
            if (length == count)
            {
                _operation = new Continuous(minValue, maxValue, members);
                return _operation;
            }
        }
        _operation = new Discontinuous(memberByValue);
        return _operation;
    }
    #endregion


    #region IsDefined
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsDefined(ref ushort value)
        => _operation.IsDefined(ref value);
    #endregion
}



/// <summary>
/// Provides int specified operation.
/// </summary>
/// <typeparam name="T">Enum type</typeparam>
internal static class Int32Operation<T>
    where T : struct, Enum
{
    #region Inner Classes
    private abstract class UnderlyingOperation : IUnderlyingOperation<T>
    {
        public abstract bool IsContinuous { get; }
        public abstract bool IsDefined(ref T value);
        public abstract bool IsDefined(ref int value);
        public abstract bool TryGetMember(ref T value, out Member<T> result);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryParse(string text, out T result)
        {
            result = default;
            ref var x = ref Unsafe.As<T, int>(ref result);
            return int.TryParse(text, out x);
        }
    }


    private sealed class Continuous : UnderlyingOperation
    {
        private readonly int _minValue;
        private readonly int _maxValue;
        private readonly Member<T>[] _members;

        public Continuous(int min, int max, Member<T>[] members)
        {
            this._minValue = min;
            this._maxValue = max;
            this._members = members;
        }

        public override bool IsContinuous
            => true;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, int>(ref value);
            return (this._minValue <= val) && (val <= this._maxValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref int value)
            => (this._minValue <= value) && (value <= this._maxValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, int>(ref value);
            var index = val - this._minValue;
            if (0 <= index && index < this._members.Length)
            {
                result = this._members[index];
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }
    }


    private sealed class Discontinuous : UnderlyingOperation
    {
        private readonly FrozenInt32KeyDictionary<Member<T>> _memberByValue;

        public Discontinuous(FrozenInt32KeyDictionary<Member<T>> memberByValue)
            => this._memberByValue = memberByValue;

        public override bool IsContinuous
            => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, int>(ref value);
            return this._memberByValue.ContainsKey(val);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref int value)
            => this._memberByValue.ContainsKey(value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, int>(ref value);
            return this._memberByValue.TryGetValue(val, out result);
        }
    }
    #endregion


    #region Fields
    private static UnderlyingOperation _operation;
    #endregion


    #region Create
    public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
    {
        var minValue = Unsafe.As<T, int>(ref min);
        var maxValue = Unsafe.As<T, int>(ref max);
        var memberByValue
            = members.ToFrozenInt32KeyDictionary(static x =>
            {
                var value = x.Value;
                return Unsafe.As<T, int>(ref value);
            });
        if (memberByValue.Count > 0)
        {
            var length = maxValue - minValue;
            var count = memberByValue.Count - 1;
            if (length == count)
            {
                _operation = new Continuous(minValue, maxValue, members);
                return _operation;
            }
        }
        _operation = new Discontinuous(memberByValue);
        return _operation;
    }
    #endregion


    #region IsDefined
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsDefined(ref int value)
        => _operation.IsDefined(ref value);
    #endregion
}



/// <summary>
/// Provides uint specified operation.
/// </summary>
/// <typeparam name="T">Enum type</typeparam>
internal static class UInt32Operation<T>
    where T : struct, Enum
{
    #region Inner Classes
    private abstract class UnderlyingOperation : IUnderlyingOperation<T>
    {
        public abstract bool IsContinuous { get; }
        public abstract bool IsDefined(ref T value);
        public abstract bool IsDefined(ref uint value);
        public abstract bool TryGetMember(ref T value, out Member<T> result);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryParse(string text, out T result)
        {
            result = default;
            ref var x = ref Unsafe.As<T, uint>(ref result);
            return uint.TryParse(text, out x);
        }
    }


    private sealed class Continuous : UnderlyingOperation
    {
        private readonly uint _minValue;
        private readonly uint _maxValue;
        private readonly Member<T>[] _members;

        public Continuous(uint min, uint max, Member<T>[] members)
        {
            this._minValue = min;
            this._maxValue = max;
            this._members = members;
        }

        public override bool IsContinuous
            => true;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, uint>(ref value);
            return (this._minValue <= val) && (val <= this._maxValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref uint value)
            => (this._minValue <= value) && (value <= this._maxValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, uint>(ref value);
            var index = val - this._minValue;
            if (0 <= index && index < this._members.Length)
            {
                result = this._members[index];
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }
    }


    private sealed class Discontinuous : UnderlyingOperation
    {
        private readonly FrozenUInt32KeyDictionary<Member<T>> _memberByValue;

        public Discontinuous(FrozenUInt32KeyDictionary<Member<T>> memberByValue)
            => this._memberByValue = memberByValue;

        public override bool IsContinuous
            => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, uint>(ref value);
            return this._memberByValue.ContainsKey(val);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref uint value)
            => this._memberByValue.ContainsKey(value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, uint>(ref value);
            return this._memberByValue.TryGetValue(val, out result);
        }
    }
    #endregion


    #region Fields
    private static UnderlyingOperation _operation;
    #endregion


    #region Create
    public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
    {
        var minValue = Unsafe.As<T, uint>(ref min);
        var maxValue = Unsafe.As<T, uint>(ref max);
        var memberByValue
            = members.ToFrozenUInt32KeyDictionary(static x =>
            {
                var value = x.Value;
                return Unsafe.As<T, uint>(ref value);
            });
        if (memberByValue.Count > 0)
        {
            var length = maxValue - minValue;
            var count = memberByValue.Count - 1;
            if (length == count)
            {
                _operation = new Continuous(minValue, maxValue, members);
                return _operation;
            }
        }
        _operation = new Discontinuous(memberByValue);
        return _operation;
    }
    #endregion


    #region IsDefined
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsDefined(ref uint value)
        => _operation.IsDefined(ref value);
    #endregion
}



/// <summary>
/// Provides long specified operation.
/// </summary>
/// <typeparam name="T">Enum type</typeparam>
internal static class Int64Operation<T>
    where T : struct, Enum
{
    #region Inner Classes
    private abstract class UnderlyingOperation : IUnderlyingOperation<T>
    {
        public abstract bool IsContinuous { get; }
        public abstract bool IsDefined(ref T value);
        public abstract bool IsDefined(ref long value);
        public abstract bool TryGetMember(ref T value, out Member<T> result);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryParse(string text, out T result)
        {
            result = default;
            ref var x = ref Unsafe.As<T, long>(ref result);
            return long.TryParse(text, out x);
        }
    }


    private sealed class Continuous : UnderlyingOperation
    {
        private readonly long _minValue;
        private readonly long _maxValue;
        private readonly Member<T>[] _members;

        public Continuous(long min, long max, Member<T>[] members)
        {
            this._minValue = min;
            this._maxValue = max;
            this._members = members;
        }

        public override bool IsContinuous
            => true;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, long>(ref value);
            return (this._minValue <= val) && (val <= this._maxValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref long value)
            => (this._minValue <= value) && (value <= this._maxValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, long>(ref value);
            var index = val - this._minValue;
            if (0 <= index && index < this._members.Length)
            {
                result = this._members[index];
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }
    }


    private sealed class Discontinuous : UnderlyingOperation
    {
        private readonly FrozenInt64KeyDictionary<Member<T>> _memberByValue;

        public Discontinuous(FrozenInt64KeyDictionary<Member<T>> memberByValue)
            => this._memberByValue = memberByValue;

        public override bool IsContinuous
            => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, long>(ref value);
            return this._memberByValue.ContainsKey(val);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref long value)
            => this._memberByValue.ContainsKey(value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, long>(ref value);
            return this._memberByValue.TryGetValue(val, out result);
        }
    }
    #endregion


    #region Fields
    private static UnderlyingOperation _operation;
    #endregion


    #region Create
    public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
    {
        var minValue = Unsafe.As<T, long>(ref min);
        var maxValue = Unsafe.As<T, long>(ref max);
        var memberByValue
            = members.ToFrozenInt64KeyDictionary(static x =>
            {
                var value = x.Value;
                return Unsafe.As<T, long>(ref value);
            });
        if (memberByValue.Count > 0)
        {
            var length = maxValue - minValue;
            var count = memberByValue.Count - 1;
            if (length == count)
            {
                _operation = new Continuous(minValue, maxValue, members);
                return _operation;
            }
        }
        _operation = new Discontinuous(memberByValue);
        return _operation;
    }
    #endregion


    #region IsDefined
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsDefined(ref long value)
        => _operation.IsDefined(ref value);
    #endregion
}



/// <summary>
/// Provides ulong specified operation.
/// </summary>
/// <typeparam name="T">Enum type</typeparam>
internal static class UInt64Operation<T>
    where T : struct, Enum
{
    #region Inner Classes
    private abstract class UnderlyingOperation : IUnderlyingOperation<T>
    {
        public abstract bool IsContinuous { get; }
        public abstract bool IsDefined(ref T value);
        public abstract bool IsDefined(ref ulong value);
        public abstract bool TryGetMember(ref T value, out Member<T> result);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryParse(string text, out T result)
        {
            result = default;
            ref var x = ref Unsafe.As<T, ulong>(ref result);
            return ulong.TryParse(text, out x);
        }
    }


    private sealed class Continuous : UnderlyingOperation
    {
        private readonly ulong _minValue;
        private readonly ulong _maxValue;
        private readonly Member<T>[] _members;

        public Continuous(ulong min, ulong max, Member<T>[] members)
        {
            this._minValue = min;
            this._maxValue = max;
            this._members = members;
        }

        public override bool IsContinuous
            => true;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, ulong>(ref value);
            return (this._minValue <= val) && (val <= this._maxValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref ulong value)
            => (this._minValue <= value) && (value <= this._maxValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, ulong>(ref value);
            var index = val - this._minValue;
            if (0 <= index && index < (ulong)this._members.Length)
            {
                result = this._members[index];
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }
    }


    private sealed class Discontinuous : UnderlyingOperation
    {
        private readonly FrozenUInt64KeyDictionary<Member<T>> _memberByValue;

        public Discontinuous(FrozenUInt64KeyDictionary<Member<T>> memberByValue)
            => this._memberByValue = memberByValue;

        public override bool IsContinuous
            => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref T value)
        {
            ref var val = ref Unsafe.As<T, ulong>(ref value);
            return this._memberByValue.ContainsKey(val);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool IsDefined(ref ulong value)
            => this._memberByValue.ContainsKey(value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool TryGetMember(ref T value, out Member<T> result)
        {
            ref var val = ref Unsafe.As<T, ulong>(ref value);
            return this._memberByValue.TryGetValue(val, out result);
        }
    }
    #endregion


    #region Fields
    private static UnderlyingOperation _operation;
    #endregion


    #region Create
    public static IUnderlyingOperation<T> Create(T min, T max, Member<T>[] members)
    {
        var minValue = Unsafe.As<T, ulong>(ref min);
        var maxValue = Unsafe.As<T, ulong>(ref max);
        var memberByValue
            = members.ToFrozenUInt64KeyDictionary(static x =>
            {
                var value = x.Value;
                return Unsafe.As<T, ulong>(ref value);
            });
        if (memberByValue.Count > 0)
        {
            var length = maxValue - minValue;
            var count = memberByValue.Count - 1;
            if (length == (ulong)count)
            {
                _operation = new Continuous(minValue, maxValue, members);
                return _operation;
            }
        }
        _operation = new Discontinuous(memberByValue);
        return _operation;
    }
    #endregion


    #region IsDefined
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsDefined(ref ulong value)
        => _operation.IsDefined(ref value);
    #endregion
}



